{"version":3,"sources":["../src/global-kill-switch.ts","../src/position-sizing.ts","../src/risk-manager.ts","../src/index.ts"],"names":["z","EventEmitter"],"mappings":";AAAA,OAAO,kBAAkB;AACzB,SAAS,SAAS;AAgClB,IAAM,yBAAyB,EAAE,OAAO;AAAA,EACtC,mBAAmB,EAAE,QAAQ;AAAA,EAC7B,cAAc,EAAE,OAAO,EAAE,SAAS;AAAA,EAClC,aAAa,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,GAAG;AAAA,EACtC,wBAAwB,EAAE,OAAO,EAAE,SAAS;AAAA,EAC5C,mBAAmB,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC;AAAA,EAC7C,yBAAyB,EAAE,OAAO,EAAE,SAAS;AAAA,EAC7C,oBAAoB,EAAE,OAAO,EAAE,SAAS;AAC1C,CAAC;AAEM,IAAM,mBAAN,cAA+B,aAAa;AAAA,EACzC;AAAA,EACA,cAAuB;AAAA,EACvB,WAAoB;AAAA,EACpB,iBAAoC,CAAC;AAAA,EACrC,cAAmD;AAAA,EACnD,aAA0B,oBAAI,IAAI;AAAA,EAClC,sBAA8B;AAAA,EAC9B,YAAoB;AAAA,EACpB,kBAA0B;AAAA,EAC1B,YAAkB,oBAAI,KAAK;AAAA,EAC3B,iBAA8C,oBAAI,IAAI;AAAA,EAE9D,YAAY,QAA0B;AACpC,UAAM;AACN,SAAK,eAAe,MAAM;AAC1B,SAAK,SAAS;AACd,SAAK,gBAAgB;AACrB,SAAK,sBAAsB;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,kBACX,QACA,WAAmD,QACnD,cAAiC,QAClB;AACf,QAAI,KAAK,aAAa;AACpB,cAAQ,KAAK,+BAA+B;AAC5C;AAAA,IACF;AAEA,UAAM,QAAyB;AAAA,MAC7B,MAAM;AAAA,MACN,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,QACR,YAAY,KAAK,WAAW;AAAA,QAC5B,WAAW,KAAK;AAAA,QAChB,iBAAiB,KAAK;AAAA,QACtB,qBAAqB,KAAK;AAAA,MAC5B;AAAA,IACF;AAEA,SAAK,cAAc;AACnB,SAAK,cAAc,aAAa,aAAa,cAAc;AAC3D,SAAK,eAAe,KAAK,KAAK;AAE9B,YAAQ,MAAM,oCAA6B,MAAM,EAAE;AACnD,YAAQ,MAAM,aAAa,QAAQ,WAAW,KAAK,WAAW,EAAE;AAGhE,SAAK,KAAK,yBAAyB,KAAK;AAGxC,QAAI,aAAa,YAAY;AAC3B,YAAM,KAAK,iBAAiB;AAAA,IAC9B,OAAO;AACL,YAAM,KAAK,oBAAoB;AAAA,IACjC;AAGA,UAAM,KAAK,2BAA2B,KAAK;AAG3C,UAAM,KAAK,mBAAmB,KAAK;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKO,6BAAmC;AACxC,QAAI,CAAC,KAAK,OAAO,qBAAqB,KAAK,aAAa;AACtD;AAAA,IACF;AAGA,QAAI,KAAK,aAAa,KAAK,OAAO,cAAc;AAC9C,WAAK;AAAA,QACH,+BAA+B,KAAK,UAAU,QAAQ,CAAC,CAAC;AAAA,QACxD;AAAA,QACA;AAAA,MACF;AACA;AAAA,IACF;AAGA,QAAI,KAAK,mBAAmB,KAAK,OAAO,aAAa;AACnD,WAAK;AAAA,QACH,8BAA8B,KAAK,gBAAgB,QAAQ,CAAC,CAAC;AAAA,QAC7D;AAAA,QACA;AAAA,MACF;AACA;AAAA,IACF;AAGA,QAAI,KAAK,uBAAuB,KAAK,OAAO,wBAAwB;AAClE,WAAK;AAAA,QACH,kCAAkC,KAAK,mBAAmB;AAAA,QAC1D;AAAA,QACA;AAAA,MACF;AACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,YAAY,OAAqB;AACtC,SAAK,WAAW,IAAI,KAAK;AACzB,SAAK,KAAK,kBAAkB,EAAE,OAAO,WAAW,KAAK,WAAW,KAAK,CAAC;AAEtE,YAAQ,IAAI,mBAAmB,KAAK,YAAY,KAAK,WAAW,IAAI,GAAG;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKO,cAAc,OAAqB;AACxC,SAAK,WAAW,OAAO,KAAK;AAC5B,SAAK,mBAAmB,KAAK;AAC7B,SAAK,KAAK,oBAAoB,EAAE,OAAO,WAAW,KAAK,WAAW,KAAK,CAAC;AAExE,YAAQ,IAAI,qBAAqB,KAAK,YAAY,KAAK,WAAW,IAAI,GAAG;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA,EAKO,WAAW,QAAsB;AACtC,SAAK,aAAa;AAClB,SAAK,KAAK,iBAAiB,EAAE,QAAQ,gBAAgB,KAAK,UAAU,CAAC;AAGrE,SAAK,eAAe;AAGpB,SAAK,2BAA2B;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKO,cAAc,OAAe,QAAsB;AACxD,SAAK;AACL,SAAK,KAAK,oBAAoB;AAAA,MAC5B;AAAA,MACA;AAAA,MACA,qBAAqB,KAAK;AAAA,IAC5B,CAAC;AAED,YAAQ,KAAK,wBAAwB,KAAK,KAAK,MAAM,KAAK,KAAK,mBAAmB,eAAe;AAGjG,SAAK,2BAA2B;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKO,cAAc,OAAqB;AACxC,SAAK,sBAAsB;AAC3B,SAAK,KAAK,oBAAoB,EAAE,MAAM,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKO,YAA8B;AACnC,WAAO;AAAA,MACL,UAAU,KAAK;AAAA,MACf,aAAa,KAAK;AAAA,MAClB,eAAe,KAAK,eAAe,SAAS,IAC1C,KAAK,eAAe,KAAK,eAAe,SAAS,CAAC,EAAE,YAAY;AAAA,MAClE,eAAe,KAAK,eAAe;AAAA,MACnC,aAAa,KAAK;AAAA,MAClB,cAAc,KAAK,sBAAsB;AAAA,MACzC,YAAY,KAAK,WAAW;AAAA,MAC5B,kBAAkB,KAAK,OAAO,kBAAkB,SAAS;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,gBAAgB,QAAgB,SAAgC;AAC3E,QAAI,CAAC,KAAK,aAAa;AACrB,cAAQ,KAAK,+CAA+C;AAC5D;AAAA,IACF;AAEA,UAAM,QAAyB;AAAA,MAC7B,MAAM;AAAA,MACN,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,QAAQ,UAAU,MAAM;AAAA,MACxB,aAAa;AAAA,MACb,UAAU;AAAA,MACV,UAAU,EAAE,QAAQ;AAAA,IACtB;AAEA,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,eAAe,KAAK,KAAK;AAE9B,YAAQ,IAAI,6BAAwB,MAAM,QAAQ,OAAO,GAAG;AAE5D,SAAK,KAAK,qBAAqB,KAAK;AACpC,UAAM,KAAK,mBAAmB,KAAK;AAGnC,eAAW,MAAM;AACf,WAAK,cAAc;AACnB,WAAK,KAAK,gBAAgB,EAAE,MAAM,SAAS,CAAC;AAAA,IAC9C,GAAG,GAAK;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKO,aAAa,WAA4C;AAC9D,UAAM,gBAAgB,EAAE,GAAG,KAAK,QAAQ,GAAG,UAAU;AACrD,SAAK,eAAe,aAAa;AACjC,SAAK,SAAS;AAEd,SAAK,KAAK,kBAAkB,aAAa;AACzC,YAAQ,IAAI,mCAAmC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKO,WAAW,QAAgB,IAAuB;AACvD,WAAO,KAAK,eAAe,MAAM,CAAC,KAAK;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKO,mBAAmB,WAAgD;AACxE,QAAI,CAAC,KAAK;AAAU,aAAO;AAC3B,QAAI,KAAK,eAAe,cAAc;AAAQ,aAAO;AACrD,QAAI,KAAK,gBAAgB,eAAe,cAAc;AAAQ,aAAO;AAErE,WAAO;AAAA,EACT;AAAA;AAAA,EAIQ,eAAe,QAAgC;AACrD,UAAM,SAAS,uBAAuB,UAAU,MAAM;AACtD,QAAI,CAAC,OAAO,SAAS;AACnB,YAAM,IAAI,MAAM,sCAAsC,OAAO,MAAM,OAAO,EAAE;AAAA,IAC9E;AAAA,EACF;AAAA,EAEA,MAAc,sBAAqC;AACjD,UAAM,eAAgC,CAAC;AAEvC,eAAW,SAAS,KAAK,YAAY;AACnC,YAAM,UAAU,KAAK,gBAAgB,KAAK;AAC1C,mBAAa,KAAK,OAAO;AAAA,IAC3B;AAEA,QAAI;AACF,YAAM,QAAQ,WAAW,YAAY;AACrC,cAAQ,IAAI,6BAA6B;AAAA,IAC3C,SAAS,OAAO;AACd,cAAQ,MAAM,+BAA+B,KAAK;AAElD,YAAM,KAAK,iBAAiB;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,MAAc,mBAAkC;AAC9C,eAAW,SAAS,KAAK,YAAY;AACnC,WAAK,KAAK,kBAAkB,EAAE,MAAM,CAAC;AACrC,WAAK,cAAc,KAAK;AAAA,IAC1B;AAEA,YAAQ,IAAI,wBAAwB;AAAA,EACtC;AAAA,EAEA,MAAc,gBAAgB,OAA8B;AAC1D,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AAEtC,YAAM,gBAAgB,WAAW,MAAM;AACrC,gBAAQ,KAAK,qCAAqC,KAAK,gBAAgB;AACvE,aAAK,KAAK,kBAAkB,EAAE,MAAM,CAAC;AACrC,gBAAQ;AAAA,MACV,GAAG,KAAK,OAAO,uBAAuB;AAEtC,WAAK,eAAe,IAAI,OAAO,aAAa;AAG5C,WAAK,KAAK,qBAAqB;AAAA,QAC7B;AAAA,QACA,SAAS,KAAK,OAAO;AAAA,MACvB,CAAC;AAGD,YAAM,aAAa,WAAW,MAAM;AAClC,aAAK,mBAAmB,KAAK;AAC7B,aAAK,KAAK,kBAAkB,EAAE,MAAM,CAAC;AACrC,gBAAQ;AAAA,MACV,GAAG,KAAK,OAAO,kBAAkB;AAGjC,YAAM,mBAAmB,CAAC,UAA6B;AACrD,YAAI,MAAM,UAAU,OAAO;AACzB,eAAK,mBAAmB,KAAK;AAC7B,uBAAa,UAAU;AACvB,eAAK,IAAI,eAAe,gBAAgB;AACxC,kBAAQ;AAAA,QACV;AAAA,MACF;AAEA,WAAK,GAAG,eAAe,gBAAgB;AAAA,IACzC,CAAC;AAAA,EACH;AAAA,EAEQ,mBAAmB,OAAqB;AAC9C,UAAM,QAAQ,KAAK,eAAe,IAAI,KAAK;AAC3C,QAAI,OAAO;AACT,mBAAa,KAAK;AAClB,WAAK,eAAe,OAAO,KAAK;AAAA,IAClC;AAAA,EACF;AAAA,EAEQ,iBAAuB;AAE7B,UAAM,sBAAuB,KAAK,YAAY,MAAS;AACvD,SAAK,kBAAkB,KAAK,IAAI,KAAK,iBAAiB,mBAAmB;AAAA,EAC3E;AAAA,EAEQ,wBAA6D;AACnE,QAAI,KAAK,eAAe,KAAK,gBAAgB,aAAa;AACxD,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,gBAAgB,cAAc,KAAK,sBAAsB,GAAG;AACnE,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,kBAAwB;AAE9B,UAAM,MAAM,oBAAI,KAAK;AACrB,UAAM,WAAW,IAAI,KAAK,GAAG;AAC7B,aAAS,WAAW,SAAS,WAAW,IAAI,CAAC;AAC7C,aAAS,YAAY,GAAG,GAAG,GAAG,CAAC;AAE/B,UAAM,oBAAoB,SAAS,QAAQ,IAAI,IAAI,QAAQ;AAE3D,eAAW,MAAM;AACf,WAAK,mBAAmB;AAGxB,kBAAY,MAAM;AAChB,aAAK,mBAAmB;AAAA,MAC1B,GAAG,KAAK,KAAK,KAAK,GAAI;AAAA,IACxB,GAAG,iBAAiB;AAAA,EACtB;AAAA,EAEQ,qBAA2B;AACjC,SAAK,YAAY;AACjB,SAAK,kBAAkB;AACvB,SAAK,YAAY,oBAAI,KAAK;AAE1B,SAAK,KAAK,eAAe;AAAA,MACvB,WAAW,KAAK,UAAU,YAAY;AAAA,IACxC,CAAC;AAED,YAAQ,IAAI,2BAA2B;AAAA,EACzC;AAAA,EAEQ,wBAA8B;AAEpC,gBAAY,MAAM;AAChB,WAAK,KAAK,gBAAgB,KAAK,UAAU,CAAC;AAAA,IAC5C,GAAG,GAAK;AAAA,EACV;AAAA,EAEA,MAAc,2BAA2B,OAAuC;AAE9E,YAAQ,IAAI,qCAA8B;AAAA,MACxC,UAAU,KAAK,OAAO;AAAA,MACtB;AAAA,IACF,CAAC;AAGD,SAAK,KAAK,0BAA0B;AAAA,MAClC;AAAA,MACA,UAAU,KAAK,OAAO;AAAA,IACxB,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,mBAAmB,OAAuC;AAEtE,YAAQ,IAAI,6BAA6B,KAAK;AAG9C,SAAK,KAAK,gBAAgB,KAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKO,UAAgB;AAErB,eAAW,SAAS,KAAK,eAAe,OAAO,GAAG;AAChD,mBAAa,KAAK;AAAA,IACpB;AACA,SAAK,eAAe,MAAM;AAG1B,SAAK,mBAAmB;AAExB,YAAQ,IAAI,uBAAuB;AAAA,EACrC;AACF;;;ACtdA,SAAS,KAAAA,UAAS;AAsDlB,IAAM,6BAA6BA,GAAE,OAAO;AAAA,EAC1C,kBAAkBA,GAAE,OAAO,EAAE,IAAI,GAAG,EAAE,IAAI,EAAE;AAAA,EAC5C,iBAAiBA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE;AAAA,EACzC,iBAAiBA,GAAE,OAAO,EAAE,SAAS;AAAA,EACrC,oBAAoBA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE;AAAA,EAC5C,cAAcA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE;AAAA,EACtC,sBAAsBA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC;AAAA,EAC7C,mBAAmBA,GAAE,KAAK,CAAC,SAAS,cAAc,SAAS,UAAU,CAAC;AAAA,EACtE,qBAAqBA,GAAE,QAAQ;AACjC,CAAC;AAEM,IAAM,uBAAN,MAA2B;AAAA,EACxB;AAAA,EACA;AAAA,EACA,mBAAqC,oBAAI,IAAI;AAAA,EAC7C,oBAA8B,CAAC;AAAA,EAC/B,kBAAuC,oBAAI,IAAI;AAAA,EAEvD,YAAY,QAA8B,gBAAwB;AAChE,SAAK,eAAe,MAAM;AAC1B,SAAK,SAAS;AACd,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKO,sBACL,QACA,QACA,YACA,eACgB;AAEhB,QAAI,WAAW,KAAK,kBAAkB,QAAQ,UAAU;AAGxD,UAAM,uBAAuB,KAAK,8BAA8B,UAAU;AAC1E,UAAM,sBAAsB,KAAK,6BAA6B,UAAU;AACxE,UAAM,wBAAwB,KAAK,+BAA+B,QAAQ,aAAa;AACvF,UAAM,0BAA0B,KAAK,iCAAiC,aAAa;AAGnF,UAAM,eAAe,WACnB,uBACA,sBACA,wBACA;AAGF,UAAM,YAAY,KAAK,oBAAoB,cAAc,aAAa;AAGtE,UAAM,aAAa,KAAK,oBAAoB,WAAW,QAAQ,UAAU;AACzE,UAAM,WAAW,KAAK,kBAAkB,WAAW,OAAO,QAAQ,YAAY,SAAS;AACvF,UAAM,aAAa,KAAK,oBAAoB,WAAW,OAAO,MAAM;AACpE,UAAM,WAAW,aAAa,KAAK,kBAAkB,KAAK,OAAO,mBAAmB;AAGpF,UAAM,cAAc,KAAK,qBAAqB,WAAW,YAAY,QAAQ,UAAU;AAGvF,UAAM,YAAY,KAAK;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,cAAc,KAAK,MAAM,YAAY,GAAG,IAAI;AAAA,MAC5C,YAAY,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,MAC3C,UAAU,KAAK,MAAM,WAAW,GAAG,IAAI;AAAA,MACvC,UAAU,KAAK,MAAM,WAAW,GAAG,IAAI;AAAA,MACvC,YAAY,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,MAC3C;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,QAAqB,YAAgC;AAC7E,UAAM,iBAAiB,KAAK,kBAAkB,KAAK,OAAO,mBAAmB;AAE7E,YAAQ,KAAK,OAAO,mBAAmB;AAAA,MACrC,KAAK;AACH,eAAO;AAAA,MAET,KAAK;AAEH,cAAM,gBAAgB,KAAK,IAAI,KAAK,KAAK,IAAI,GAAK,WAAW,aAAa,GAAG,CAAC;AAC9E,eAAO,iBAAiB;AAAA,MAE1B,KAAK;AACH,eAAO,KAAK,mBAAmB,QAAQ,YAAY,cAAc;AAAA,MAEnE,KAAK;AACH,eAAO,KAAK,sBAAsB,QAAQ,YAAY,cAAc;AAAA,MAEtE;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB,QAAqB,YAAwB,YAA4B;AAClG,UAAM,iBAAiB,OAAO;AAC9B,UAAM,SAAS,OAAO;AACtB,UAAM,UAAU,CAAC,OAAO,iBAAiB,OAAO;AAIhD,UAAM,IAAI,KAAK,IAAI,SAAS,OAAO;AACnC,UAAM,iBAAiB,IAAI,kBAAkB,IAAI,mBAAmB;AAGpE,UAAM,oBAAoB,KAAK,IAAI,GAAG,KAAK,IAAI,MAAM,gBAAgB,IAAI,CAAC;AAE1E,WAAO,KAAK,iBAAiB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAAsB,QAAqB,YAAwB,YAA4B;AAErG,UAAM,oBAAoB,KAAK,2BAA2B;AAC1D,UAAM,wBAAwB,KAAK,IAAI,KAAK,KAAK,IAAI,GAAK,iBAAiB,CAAC;AAG5E,UAAM,uBAAuB,MAAO,OAAO,aAAa;AAExD,WAAO,aAAa,wBAAwB;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKQ,8BAA8B,YAAgC;AAEpE,UAAM,gBAAgB,WAAW,aAAa;AAC9C,WAAO,KAAK,IAAI,KAAK,KAAK,IAAI,GAAK,IAAI,KAAK,KAAK,aAAa,CAAC,CAAC;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B,YAAgC;AAEnE,UAAM,gBAAgB,KAAK,IAAI,KAAK,IAAK,WAAW,SAAS,EAAG;AAChE,UAAM,cAAc,KAAK,IAAI,KAAK,KAAK,KAAK,WAAW,YAAY,GAAO,CAAC;AAE3E,WAAO,gBAAgB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKQ,+BAA+B,QAAgB,eAAsC;AAE3F,QAAI,cAAc,cAAc,KAAK,OAAO,sBAAsB;AAChE,YAAM,qBAAqB,KAAK,cAAc,cAAc,KAAK,OAAO;AACxE,aAAO,KAAK,IAAI,KAAK,kBAAkB;AAAA,IACzC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,iCAAiC,eAAsC;AAE7E,UAAM,kBAAkB,cAAc,YAAY,KAAK,OAAO;AAE9D,QAAI,kBAAkB,KAAK;AACzB,aAAO,KAAK,IAAI,KAAK,IAAI,eAAe;AAAA,IAC1C;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,MAAc,eAAsC;AAE9E,UAAM,UAAU,KAAK,IAAI,KAAK,OAAO,iBAAiB,IAAI;AAG1D,UAAM,UAAU,KAAK,kBAAkB,KAAK,OAAO,kBAAkB;AACrE,UAAM,cAAc,KAAK,IAAI,SAAS,OAAO;AAG7C,UAAM,qBAAqB,KAAK,OAAO,eAAe,cAAc;AACpE,UAAM,mBAAmB,KAAK,kBAAkB,qBAAqB;AAErE,WAAO,KAAK,IAAI,aAAa,gBAAgB;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,cAAsB,QAAqB,YAAgC;AAErG,UAAM,mBAAmB,KAAK,0BAA0B,QAAQ,UAAU;AAC1E,WAAO,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,OAAe,QAAqB,YAAoB,cAA8B;AAC9G,UAAM,mBAAmB,aAAa;AAEtC,QAAI,OAAO,cAAc,QAAQ;AAC/B,aAAO,SAAS,IAAI;AAAA,IACtB,OAAO;AACL,aAAO,SAAS,IAAI;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,OAAe,QAA6B;AACtE,UAAM,eAAe,OAAO;AAE5B,QAAI,OAAO,cAAc,QAAQ;AAC/B,aAAO,SAAS,IAAI;AAAA,IACtB,OAAO;AACL,aAAO,SAAS,IAAI;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B,QAAqB,YAAgC;AAErF,UAAM,iBAAiB,WAAW,aAAa,KAAK,KAAK,IAAE,GAAG;AAC9D,UAAM,uBAAuB,KAAK,IAAI,OAAO;AAE7C,WAAO,KAAK,IAAI,KAAK,iBAAiB,uBAAuB,CAAC;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKQ,qBACN,cACA,YACA,QACA,YAC+B;AAC/B,UAAM,gBAAiB,aAAa,KAAK,iBAAkB;AAC3D,UAAM,WAAW,KAAK,kBAAkB,cAAc,UAAU;AAChE,UAAM,qBAAqB,KAAK,4BAA4B,QAAQ,YAAY;AAChF,UAAM,0BAA0B,KAAK,iCAAiC,UAAU;AAEhF,WAAO;AAAA,MACL,eAAe,KAAK,MAAM,gBAAgB,GAAG,IAAI;AAAA,MACjD,UAAU,KAAK,MAAM,WAAW,GAAG,IAAI;AAAA,MACvC,oBAAoB,KAAK,MAAM,qBAAqB,GAAI,IAAI;AAAA,MAC5D,yBAAyB,KAAK,MAAM,0BAA0B,GAAG,IAAI;AAAA,IACvE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,cAAsB,YAAgC;AAE9E,UAAM,WAAW,WAAW,aAAa,KAAK,KAAK,IAAE,GAAG;AACxD,WAAO,eAAe,WAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKQ,4BAA4B,QAAqB,cAA8B;AACrF,UAAM,SAAS,eAAe,KAAK;AACnC,UAAM,iBAAiB,OAAO,iBAAiB,OAAO;AACtD,UAAM,eAAe;AAErB,WAAO,UAAU,iBAAiB;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKQ,iCAAiC,YAA4B;AAEnE,WAAQ,aAAa,KAAK,iBAAkB;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAAqC;AAC3C,QAAI,KAAK,kBAAkB,SAAS,IAAI;AACtC,aAAO;AAAA,IACT;AAEA,UAAM,gBAAgB,KAAK,kBAAkB,MAAM,GAAG;AACtD,UAAM,UAAU,cAAc,OAAO,OAAK,IAAI,CAAC,EAAE,SAAS,cAAc;AACxE,UAAM,YAAY,cAAc,OAAO,CAAC,KAAK,MAAM,MAAM,GAAG,CAAC,IAAI,cAAc;AAG/E,WAAQ,UAAU,MAAQ,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,YAAY,EAAE,CAAC,IAAI,MAAO;AAAA,EACnF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBACN,UACA,cACA,WACA,aAMQ;AACR,UAAM,UAAoB,CAAC;AAE3B,YAAQ,KAAK,eAAe,SAAS,QAAQ,CAAC,CAAC,KAAK,KAAK,OAAO,iBAAiB,UAAU;AAE3F,QAAI,KAAK,IAAI,YAAY,uBAAuB,CAAC,IAAI,KAAK;AACxD,YAAM,SAAS,YAAY,uBAAuB,IAAI,cAAc;AACpE,cAAQ,KAAK,GAAG,MAAM,OAAO,KAAK,IAAI,YAAY,uBAAuB,CAAC,EAAE,QAAQ,CAAC,CAAC,kBAAkB;AAAA,IAC1G;AAEA,QAAI,KAAK,IAAI,YAAY,sBAAsB,CAAC,IAAI,KAAK;AACvD,YAAM,SAAS,YAAY,sBAAsB,IAAI,cAAc;AACnE,cAAQ,KAAK,GAAG,MAAM,OAAO,KAAK,IAAI,YAAY,sBAAsB,CAAC,EAAE,QAAQ,CAAC,CAAC,iBAAiB;AAAA,IACxG;AAEA,QAAI,KAAK,IAAI,YAAY,wBAAwB,CAAC,IAAI,KAAK;AACzD,cAAQ,KAAK,eAAe,IAAI,YAAY,uBAAuB,QAAQ,CAAC,CAAC,wBAAwB;AAAA,IACvG;AAEA,QAAI,KAAK,IAAI,YAAY,0BAA0B,CAAC,IAAI,KAAK;AAC3D,cAAQ,KAAK,eAAe,IAAI,YAAY,yBAAyB,QAAQ,CAAC,CAAC,sBAAsB;AAAA,IACvG;AAEA,QAAI,cAAc,cAAc;AAC9B,cAAQ,KAAK,eAAe,UAAU,QAAQ,CAAC,CAAC,0BAA0B;AAAA,IAC5E;AAEA,WAAO,QAAQ,KAAK,IAAI;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe,WAAyB;AAC7C,SAAK,kBAAkB,KAAK,SAAS;AAGrC,QAAI,KAAK,kBAAkB,SAAS,KAAK;AACvC,WAAK,oBAAoB,KAAK,kBAAkB,MAAM,IAAI;AAAA,IAC5D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,qBAAqB,UAAwB;AAClD,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKO,aAAa,WAAgD;AAClE,UAAM,gBAAgB,EAAE,GAAG,KAAK,QAAQ,GAAG,UAAU;AACrD,SAAK,eAAe,aAAa;AACjC,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKO,YAAkC;AACvC,WAAO,EAAE,GAAG,KAAK,OAAO;AAAA,EAC1B;AAAA,EAEQ,eAAe,QAAoC;AACzD,UAAM,SAAS,2BAA2B,UAAU,MAAM;AAC1D,QAAI,CAAC,OAAO,SAAS;AACnB,YAAM,IAAI,MAAM,0CAA0C,OAAO,MAAM,OAAO,EAAE;AAAA,IAClF;AAAA,EACF;AACF;;;AC3cA,OAAOC,mBAAkB;AA6ElB,IAAM,cAAN,cAA0BA,cAAa;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAmC,oBAAI,IAAI;AAAA,EAC3C;AAAA,EACA,SAAiC,oBAAI,IAAI;AAAA,EACzC,iBAAuB,oBAAI,KAAK;AAAA,EAChC,cAA4B,CAAC;AAAA,EAErC,YAAY,QAA2B,gBAAwB;AAC7D,UAAM;AACN,SAAK,SAAS;AACd,SAAK,iBAAiB;AAGtB,SAAK,aAAa,IAAI,iBAAiB,OAAO,UAAU;AACxD,SAAK,iBAAiB,IAAI,qBAAqB,OAAO,gBAAgB,cAAc;AAEpF,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKO,sBACL,QACA,QACA,YACgB;AAEhB,QAAI,CAAC,KAAK,WAAW,mBAAmB,OAAO,GAAG;AAChD,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAGA,UAAM,gBAAgB,KAAK,uBAAuB;AAGlD,QAAI,cAAc,YAAY,KAAK,OAAO,gBAAgB,kBAAkB;AAC1E,YAAM,IAAI,MAAM,mBAAmB,cAAc,UAAU,QAAQ,CAAC,CAAC,qBAAqB,KAAK,OAAO,gBAAgB,gBAAgB,IAAI;AAAA,IAC5I;AAGA,UAAM,iBAAiB,KAAK,eAAe;AAAA,MACzC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,SAAK,oBAAoB,QAAQ,gBAAgB,aAAa;AAE9D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,YAAY,UAA0B;AAC3C,SAAK,UAAU,IAAI,SAAS,IAAI,QAAQ;AACxC,SAAK,WAAW,YAAY,SAAS,EAAE;AAEvC,SAAK,KAAK,kBAAkB,QAAQ;AAGpC,SAAK,gBAAgB;AACrB,SAAK,mBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe,YAAoB,SAAkC;AAC1E,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU;AAC9C,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,YAAY,UAAU,YAAY;AAAA,IACpD;AAEA,UAAM,kBAAkB,EAAE,GAAG,UAAU,GAAG,QAAQ;AAClD,SAAK,UAAU,IAAI,YAAY,eAAe;AAE9C,SAAK,KAAK,oBAAoB,eAAe;AAG7C,SAAK,kBAAkB,eAAe;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe,YAA0B;AAC9C,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU;AAC9C,QAAI,UAAU;AACZ,WAAK,UAAU,OAAO,UAAU;AAChC,WAAK,WAAW,cAAc,UAAU;AAExC,WAAK,KAAK,oBAAoB,QAAQ;AAGtC,WAAK,mBAAmB;AAAA,IAC1B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAkB,YAAoB,KAAa,SAAwB;AAChF,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU;AAC9C,QAAI,CAAC;AAAU;AAEf,UAAM,YAAY,MAAM,SAAS;AAGjC,SAAK,eAAe,eAAe,SAAS;AAG5C,QAAI,SAAS;AACX,WAAK,WAAW,cAAc,UAAU;AAAA,IAC1C,OAAO;AACL,WAAK,WAAW,cAAc,YAAY,eAAe,IAAI,QAAQ,CAAC,CAAC,EAAE;AAAA,IAC3E;AAGA,QAAI,MAAM,GAAG;AACX,WAAK,WAAW,WAAW,KAAK,IAAI,GAAG,CAAC;AAAA,IAC1C;AAEA,SAAK,KAAK,gBAAgB,EAAE,YAAY,KAAK,SAAS,UAAU,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKO,mBAAkC;AACvC,WAAO,KAAK,uBAAuB;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKO,qBAAiC;AACtC,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY;AACzC,UAAM,gBAAgB,KAAK,uBAAuB;AAClD,UAAM,mBAAmB,KAAK,WAAW,UAAU;AAGnD,QAAI;AACJ,QAAI,KAAK,oBAAoB,GAAG;AAC9B,0BAAoB,KAAK,eAAe;AAAA,IAC1C;AAGA,UAAM,kBAAkB,KAAK,wBAAwB,eAAe,iBAAiB;AAGrF,UAAM,SAAS,MAAM,KAAK,KAAK,OAAO,OAAO,CAAC;AAE9C,UAAM,SAAqB;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,SAAK,YAAY,KAAK,MAAM;AAG5B,QAAI,KAAK,YAAY,SAAS,KAAK;AACjC,WAAK,cAAc,KAAK,YAAY,MAAM,IAAI;AAAA,IAChD;AAEA,SAAK,KAAK,yBAAyB,MAAM;AAEzC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,qBAAqB,QAA+B;AAC/D,UAAM,KAAK,WAAW,kBAAkB,QAAQ,YAAY,MAAM;AAGlE,eAAW,YAAY,KAAK,UAAU,OAAO,GAAG;AAC9C,WAAK,KAAK,4BAA4B,QAAQ;AAAA,IAChD;AAEA,SAAK,YAAY,kBAAkB,YAAY,6BAA6B,MAAM,IAAI,CAAC,CAAC;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe,OAAe,IAAkB;AACrD,UAAM,aAAa,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,KAAK,GAAI;AACnE,WAAO,KAAK,YAAY;AAAA,MAAO,YAC7B,IAAI,KAAK,OAAO,SAAS,KAAK;AAAA,IAChC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,qBAAqB,UAAwB;AAClD,SAAK,iBAAiB;AACtB,SAAK,eAAe,qBAAqB,QAAQ;AAEjD,SAAK,KAAK,2BAA2B,QAAQ;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKO,iBAAiB,SAAuB;AAC7C,UAAM,QAAQ,KAAK,OAAO,IAAI,OAAO;AACrC,QAAI,OAAO;AACT,YAAM,eAAe;AACrB,WAAK,KAAK,sBAAsB,KAAK;AAAA,IACvC;AAAA,EACF;AAAA;AAAA,EAIQ,sBAA4B;AAElC,SAAK,WAAW,GAAG,yBAAyB,CAAC,UAAU;AACrD,WAAK,KAAK,yBAAyB,KAAK;AACxC,WAAK,YAAY,cAAc,YAAY,0BAA0B,MAAM,MAAM,IAAI,CAAC,CAAC;AAAA,IACzF,CAAC;AAED,SAAK,WAAW,GAAG,0BAA0B,CAAC,SAAS;AACrD,WAAK,KAAK,0BAA0B,IAAI;AAAA,IAC1C,CAAC;AAAA,EACH;AAAA,EAEQ,sBAA4B;AAElC,gBAAY,MAAM;AAChB,WAAK,gBAAgB;AACrB,WAAK,mBAAmB;AAAA,IAC1B,GAAG,GAAK;AAGR,gBAAY,MAAM;AAChB,UAAI,KAAK,oBAAoB,GAAG;AAC9B,aAAK,eAAe;AAAA,MACtB;AAAA,IACF,GAAG,KAAK,KAAK,GAAI;AAAA,EACnB;AAAA,EAEQ,yBAAwC;AAC9C,UAAM,YAAY,MAAM,KAAK,KAAK,UAAU,OAAO,CAAC;AAEpD,QAAI,UAAU,WAAW,GAAG;AAC1B,aAAO;AAAA,QACL,WAAW;AAAA,QACX,WAAW;AAAA,QACX,eAAe;AAAA,QACf,aAAa;AAAA,QACb,UAAU;AAAA,QACV,eAAe;AAAA,MACjB;AAAA,IACF;AAEA,UAAM,aAAa,UAAU,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,IAAI,IAAI,IAAI,GAAG,CAAC;AAC7E,UAAM,YAAY,UAAU,OAAO,CAAC,KAAK,QAAQ,MAAM,IAAI,YAAY,CAAC;AACxE,UAAM,WAAW,UAAU,OAAO,CAAC,KAAK,QAAQ,MAAM,IAAI,KAAK,CAAC;AAGhE,UAAM,cAAc,KAAK,IAAI,GAAG,UAAU,IAAI,SAAO,KAAK,IAAI,IAAI,IAAI,CAAC,CAAC;AACxE,UAAM,gBAAiB,cAAc,KAAK,iBAAkB;AAG5D,UAAM,cAAc,KAAK,4BAA4B,SAAS;AAG9D,UAAM,WAAW,aAAa,KAAK;AAGnC,UAAM,YAAa,KAAK,IAAI,QAAQ,IAAI,KAAK,iBAAkB;AAG/D,UAAM,gBAAgB,KAAK,IAAI,KAAK,UAAU,SAAS,CAAC;AAExD,WAAO;AAAA,MACL,WAAY,YAAY,KAAK,iBAAkB;AAAA,MAC/C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,4BAA4B,WAA+B;AAGjE,UAAM,UAAU,IAAI,IAAI,UAAU,IAAI,SAAO,IAAI,UAAU,SAAS,CAAC;AACrE,UAAM,iBAAiB,KAAK,IAAI,GAAG,MAAM,KAAK,OAAO,EAAE;AAAA,MAAI,YACzD,UAAU,OAAO,UAAQ,IAAI,UAAU,eAAe,MAAM,EAAE;AAAA,IAChE,CAAC;AAED,WAAO,KAAK,IAAI,GAAG,iBAAiB,UAAU,MAAM;AAAA,EACtD;AAAA,EAEQ,kBAAwB;AAC9B,UAAM,gBAAgB,KAAK,uBAAuB;AAGlD,QAAI,cAAc,YAAY,KAAK,OAAO,gBAAgB,kBAAkB;AAC1E,WAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,mBAAmB,cAAc,UAAU,QAAQ,CAAC,CAAC,qBAAqB,KAAK,OAAO,gBAAgB,gBAAgB;AAAA,QACtH,CAAC;AAAA,MACH;AAAA,IACF;AAGA,QAAI,cAAc,gBAAgB,KAAK,OAAO,gBAAgB,wBAAwB;AACpF,WAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,2BAA2B,cAAc,cAAc,QAAQ,CAAC,CAAC,qBAAqB,KAAK,OAAO,gBAAgB,sBAAsB;AAAA,QACxI,CAAC;AAAA,MACH;AAAA,IACF;AAGA,QAAI,cAAc,cAAc,KAAK,OAAO,gBAAgB,gBAAgB;AAC1E,WAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,0BAA0B,cAAc,YAAY,QAAQ,CAAC,CAAC,oBAAoB,KAAK,OAAO,gBAAgB,cAAc;AAAA,QAC5H,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,kBAAkB,UAA0B;AAElD,UAAM,YAAa,SAAS,aAAa,SAAS,gBAAgB,SAAS,aAAc;AACzF,UAAM,cAAc,KAAK,IAAI,QAAQ;AAErC,QAAI,cAAc,IAAI;AACpB,WAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,YAAY,SAAS,MAAM,QAAQ,YAAY,QAAQ,CAAC,CAAC;AAAA,QACzD,CAAC,SAAS,EAAE;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,oBAAoB,QAAgB,gBAAgC,eAAoC;AAE9G,UAAM,mBAAoB,eAAe,eAAe,KAAK,iBAAkB;AAC/E,QAAI,mBAAmB,KAAK,OAAO,gBAAgB,wBAAwB;AACzE,YAAM,IAAI,MAAM,mDAAmD,iBAAiB,QAAQ,CAAC,CAAC,OAAO,KAAK,OAAO,gBAAgB,sBAAsB,GAAG;AAAA,IAC5J;AAGA,UAAM,eAAe,cAAc,YAAY,eAAe,YAAY;AAC1E,QAAI,eAAe,KAAK,OAAO,gBAAgB,kBAAkB;AAC/D,YAAM,IAAI,MAAM,mDAAmD,aAAa,QAAQ,CAAC,CAAC,OAAO,KAAK,OAAO,gBAAgB,gBAAgB,GAAG;AAAA,IAClJ;AAAA,EACF;AAAA,EAEQ,sBAA+B;AACrC,QAAI,CAAC,KAAK,OAAO,WAAW;AAAS,aAAO;AAE5C,UAAM,qBAAqB,KAAK,IAAI,IAAI,KAAK,eAAe,QAAQ,MAAM,MAAO,KAAK,KAAK;AAC3F,WAAO,qBAAqB;AAAA,EAC9B;AAAA,EAEQ,iBAAqC;AAC3C,SAAK,iBAAiB,oBAAI,KAAK;AAE/B,UAAM,UAA8B,CAAC;AACrC,UAAM,YAAY,MAAM,KAAK,KAAK,UAAU,OAAO,CAAC;AAEpD,eAAW,YAAY,KAAK,OAAO,WAAW,WAAW;AACvD,YAAM,SAAS,KAAK,oBAAoB,UAAU,SAAS;AAC3D,cAAQ,KAAK,MAAM;AAEnB,UAAI,CAAC,OAAO,QAAQ;AAClB,aAAK;AAAA,UACH;AAAA,UACA;AAAA,UACA,uBAAuB,SAAS,IAAI,qBAAqB,OAAO,aAAa,QAAQ,CAAC,CAAC;AAAA,UACvF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,SAAK,KAAK,yBAAyB,OAAO;AAC1C,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB,UAA8B,WAAyC;AACjG,QAAI,YAAY;AAChB,QAAI,eAAe;AAEnB,eAAW,YAAY,WAAW;AAEhC,YAAM,aAAa,SAAS,cAAc;AAC1C,YAAM,aAAa,SAAS,cAAc,SACxC,SAAS,gBAAgB,IAAI,cAC7B,SAAS,gBAAgB,IAAI;AAE/B,YAAM,MAAM,SAAS,cAAc,UAChC,aAAa,SAAS,eAAe,SAAS,OAAO,SAAS,eAC9D,SAAS,aAAa,eAAe,SAAS,OAAO,SAAS;AAEjE,mBAAa,KAAK,IAAI,GAAG;AACzB,sBAAgB,KAAK,IAAI,GAAG,IAAI,SAAS;AAAA,IAC3C;AAEA,UAAM,iBAAkB,YAAY,KAAK,iBAAkB;AAC3D,UAAM,gBAAiB,eAAe,KAAK,iBAAkB;AAC7D,UAAM,SAAS,kBAAkB,KAAK,OAAO,WAAW;AAExD,WAAO;AAAA,MACL,UAAU,SAAS;AAAA,MACnB,cAAc;AAAA,MACd,cAAc;AAAA,MACd,gBAAgB,KAAK,KAAK,iBAAiB,CAAC;AAAA;AAAA,MAC5C;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,wBAAwB,eAA8B,mBAA8D;AAC1H,UAAM,kBAAwC,CAAC;AAG/C,QAAI,cAAc,YAAY,KAAK,OAAO,gBAAgB,mBAAmB,KAAK;AAChF,sBAAgB,KAAK;AAAA,QACnB,MAAM;AAAA,QACN,UAAU;AAAA,QACV,aAAa;AAAA,QACb,gBAAgB,8BAA8B,cAAc,UAAU,QAAQ,CAAC,CAAC,cAAc,KAAK,OAAO,gBAAgB,gBAAgB;AAAA,MAC5I,CAAC;AAAA,IACH;AAGA,QAAI,cAAc,gBAAgB,KAAK,OAAO,gBAAgB,yBAAyB,KAAK;AAC1F,sBAAgB,KAAK;AAAA,QACnB,MAAM;AAAA,QACN,UAAU;AAAA,QACV,aAAa;AAAA,QACb,gBAAgB,kCAAkC,cAAc,cAAc,QAAQ,CAAC,CAAC;AAAA,MAC1F,CAAC;AAAA,IACH;AAGA,QAAI,cAAc,cAAc,KAAK,OAAO,gBAAgB,iBAAiB,KAAK;AAChF,sBAAgB,KAAK;AAAA,QACnB,MAAM;AAAA,QACN,UAAU;AAAA,QACV,aAAa;AAAA,QACb,gBAAgB,2BAA2B,cAAc,YAAY,QAAQ,CAAC,CAAC,aAAa,KAAK,OAAO,gBAAgB,cAAc;AAAA,MACxI,CAAC;AAAA,IACH;AAGA,QAAI,mBAAmB,KAAK,YAAU,CAAC,OAAO,MAAM,GAAG;AACrD,sBAAgB,KAAK;AAAA,QACnB,MAAM;AAAA,QACN,UAAU;AAAA,QACV,aAAa;AAAA,QACb,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,YACN,MACA,UACA,SACA,WACM;AACN,UAAM,QAAmB;AAAA,MACvB,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,cAAc;AAAA,MACd;AAAA,IACF;AAEA,SAAK,OAAO,IAAI,MAAM,IAAI,KAAK;AAC/B,SAAK,KAAK,cAAc,KAAK;AAG7B,UAAM,aAAa,MAAM,KAAK,KAAK,OAAO,OAAO,CAAC;AAClD,QAAI,WAAW,SAAS,IAAI;AAC1B,YAAM,eAAe,WAClB,KAAK,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAAI,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,CAAC,EAChF,MAAM,GAAG,WAAW,SAAS,EAAE;AAElC,iBAAW,YAAY,cAAc;AACnC,aAAK,OAAO,OAAO,SAAS,EAAE;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,UAAgB;AACrB,SAAK,WAAW,QAAQ;AACxB,SAAK,mBAAmB;AACxB,SAAK,UAAU,MAAM;AACrB,SAAK,OAAO,MAAM;AAAA,EACpB;AACF;;;ACjjBO,IAAM,gCAAgC,OAAyB;AAAA,EACpE,mBAAmB;AAAA,EACnB,cAAc;AAAA;AAAA,EACd,aAAa;AAAA;AAAA,EACb,wBAAwB;AAAA,EACxB,mBAAmB,CAAC;AAAA,EACpB,yBAAyB;AAAA;AAAA,EACzB,oBAAoB;AAAA;AACtB;AAEO,IAAM,oCAAoC,OAA6B;AAAA,EAC5E,kBAAkB;AAAA;AAAA,EAClB,iBAAiB;AAAA;AAAA,EACjB,iBAAiB;AAAA;AAAA,EACjB,oBAAoB;AAAA;AAAA,EACpB,cAAc;AAAA;AAAA,EACd,sBAAsB;AAAA;AAAA,EACtB,mBAAmB;AAAA,EACnB,qBAAqB;AACvB;AAEO,IAAM,mCAAmC,MAA4B;AAAA,EAC1E;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,aAAa;AAAA,IACb,sBAAsB;AAAA,IACtB,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,EACvB;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,aAAa;AAAA,IACb,sBAAsB;AAAA,IACtB,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,EACvB;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,aAAa;AAAA,IACb,sBAAsB;AAAA,IACtB,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,EACvB;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,aAAa;AAAA,IACb,sBAAsB;AAAA,IACtB,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,EACvB;AACF;AAEO,IAAM,iCAAiC,OAA0B;AAAA,EACtE,YAAY,8BAA8B;AAAA,EAC1C,gBAAgB,kCAAkC;AAAA,EAClD,iBAAiB;AAAA,IACf,kBAAkB;AAAA;AAAA,IAClB,wBAAwB;AAAA;AAAA,IACxB,gBAAgB;AAAA;AAAA,IAChB,oBAAoB;AAAA;AAAA,EACtB;AAAA,EACA,YAAY;AAAA,IACV,SAAS;AAAA,IACT,WAAW,iCAAiC;AAAA,IAC5C,kBAAkB;AAAA;AAAA,EACpB;AACF;AAGO,IAAM,uBAAuB,CAAC,SAAmB,eAAuB,SAAiB;AAC9F,MAAI,QAAQ,WAAW;AAAG,WAAO;AAEjC,QAAM,YAAY,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,GAAG,CAAC,IAAI,QAAQ;AACnE,QAAM,WAAW,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,KAAK,IAAI,IAAI,WAAW,CAAC,GAAG,CAAC,IAAI,QAAQ;AAC3F,QAAM,aAAa,KAAK,KAAK,QAAQ;AAErC,SAAO,aAAa,KAAK,YAAY,gBAAgB,aAAa;AACpE;AAEO,IAAM,uBAAuB,CAAC,YAA8B;AACjE,MAAI,QAAQ,WAAW;AAAG,WAAO;AAEjC,MAAI,OAAO;AACX,MAAI,cAAc;AAClB,MAAI,aAAa;AAEjB,aAAW,OAAO,SAAS;AACzB,kBAAc;AACd,WAAO,KAAK,IAAI,MAAM,UAAU;AAChC,UAAM,YAAY,OAAO,cAAc,KAAK,IAAI,MAAM,CAAC;AACvD,kBAAc,KAAK,IAAI,aAAa,QAAQ;AAAA,EAC9C;AAEA,SAAO;AACT;AAEO,IAAM,eAAe,CAAC,SAAmB,kBAA0B,SAAiB;AACzF,MAAI,QAAQ,WAAW;AAAG,WAAO;AAEjC,QAAM,gBAAgB,CAAC,GAAG,OAAO,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AACvD,QAAM,QAAQ,KAAK,OAAO,IAAI,mBAAmB,cAAc,MAAM;AAErE,SAAO,cAAc,KAAK,KAAK;AACjC;AAEO,IAAM,uBAAuB,CAAC,UAAoB,aAA+B;AACtF,MAAI,SAAS,WAAW,SAAS,UAAU,SAAS,WAAW;AAAG,WAAO;AAEzE,QAAM,QAAQ,SAAS,OAAO,CAAC,KAAK,MAAM,MAAM,GAAG,CAAC,IAAI,SAAS;AACjE,QAAM,QAAQ,SAAS,OAAO,CAAC,KAAK,MAAM,MAAM,GAAG,CAAC,IAAI,SAAS;AAEjE,MAAI,YAAY;AAChB,MAAI,SAAS;AACb,MAAI,SAAS;AAEb,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,UAAM,QAAQ,SAAS,CAAC,IAAI;AAC5B,UAAM,QAAQ,SAAS,CAAC,IAAI;AAE5B,iBAAa,QAAQ;AACrB,cAAU,QAAQ;AAClB,cAAU,QAAQ;AAAA,EACpB;AAEA,QAAM,cAAc,KAAK,KAAK,SAAS,MAAM;AAC7C,SAAO,cAAc,IAAI,YAAY,cAAc;AACrD;AAGO,IAAM,oBAAoB,CAC/B,eACA,YAC2C;AAC3C,QAAM,YAAY,gBAAgB;AAElC,MAAI,aAAa;AAAK,WAAO;AAC7B,MAAI,aAAa;AAAM,WAAO;AAC9B,MAAI,aAAa;AAAK,WAAO;AAC7B,SAAO;AACT;AAGO,IAAM,yBAAyB,CACpC,gBACA,QACA,YACW;AACX,MAAI,YAAY;AAAG,WAAO;AAE1B,QAAM,IAAI,KAAK,IAAI,SAAS,OAAO;AACnC,QAAM,iBAAiB,IAAI,kBAAkB,IAAI,mBAAmB;AAGpE,SAAO,KAAK,IAAI,GAAG,KAAK,IAAI,MAAM,gBAAgB,IAAI,CAAC;AACzD;AAGO,IAAM,kBAAkB,CAC7B,MACA,UACA,SACA,YAAsB,CAAC,OACR;AAAA,EACf,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAAA,EACpE;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,EAClC,cAAc;AAAA,EACd;AACF;AAGO,IAAM,yBAAyB,CACpC,WACA,mBAMG;AACH,MAAI,UAAU,WAAW,GAAG;AAC1B,WAAO;AAAA,MACL,sBAAsB;AAAA,MACtB,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,MAChB,eAAe;AAAA,IACjB;AAAA,EACF;AAGA,QAAM,UAAU,IAAI,IAAI,UAAU,IAAI,OAAK,EAAE,UAAU,SAAS,CAAC;AACjE,QAAM,uBAAuB,KAAK,IAAI,KAAM,QAAQ,OAAO,KAAK,IAAI,UAAU,SAAS,GAAG,CAAC,IAAK,GAAG;AAGnG,QAAM,gBAAgB,UAAU,IAAI,OAAK,KAAK,IAAI,EAAE,IAAI,CAAC;AACzD,QAAM,cAAc,KAAK,IAAI,GAAG,aAAa;AAC7C,QAAM,oBAAqB,cAAc,iBAAkB;AAG3D,QAAM,kBAAkB,cAAc,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC,IAAI,UAAU;AACvF,QAAM,iBAAiB,KAAK,IAAI,GAAG,MAAO,kBAAkB,iBAAkB,EAAE;AAGhF,QAAM,YAAY,wBAAwB,MAAM,qBAAqB,kBAAkB;AACvF,MAAI;AAEJ,MAAI,YAAY;AAAI,oBAAgB;AAAA,WAC3B,YAAY;AAAI,oBAAgB;AAAA,WAChC,YAAY;AAAI,oBAAgB;AAAA;AACpC,oBAAgB;AAErB,SAAO;AAAA,IACL,sBAAsB,KAAK,MAAM,oBAAoB;AAAA,IACrD,mBAAmB,KAAK,MAAM,oBAAoB,GAAG,IAAI;AAAA,IACzD,gBAAgB,KAAK,MAAM,cAAc;AAAA,IACzC;AAAA,EACF;AACF;AAGO,IAAM,UAAU","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { z } from 'zod';\n\nexport interface KillSwitchConfig {\n  enableAutoTrigger: boolean;\n  maxDailyLoss: number; // USD\n  maxDrawdown: number; // Percentage\n  maxConsecutiveFailures: number;\n  emergencyContacts: string[]; // Email addresses\n  gracefulShutdownTimeout: number; // milliseconds\n  forceShutdownAfter: number; // milliseconds\n}\n\nexport interface KillSwitchEvent {\n  type: 'triggered' | 'manual_stop' | 'force_stop' | 'recovery_mode';\n  timestamp: string;\n  reason: string;\n  triggeredBy: 'user' | 'system' | 'auto';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  metadata?: Record<string, any>;\n}\n\nexport interface KillSwitchStatus {\n  isActive: boolean;\n  isTriggered: boolean;\n  lastTriggered?: string;\n  totalTriggers: number;\n  currentMode: 'normal' | 'recovery' | 'emergency';\n  systemHealth: 'healthy' | 'degraded' | 'critical';\n  activeBots: number;\n  emergencyContact: boolean;\n}\n\nconst KillSwitchConfigSchema = z.object({\n  enableAutoTrigger: z.boolean(),\n  maxDailyLoss: z.number().positive(),\n  maxDrawdown: z.number().min(0).max(100),\n  maxConsecutiveFailures: z.number().positive(),\n  emergencyContacts: z.array(z.string().email()),\n  gracefulShutdownTimeout: z.number().positive(),\n  forceShutdownAfter: z.number().positive()\n});\n\nexport class GlobalKillSwitch extends EventEmitter {\n  private config: KillSwitchConfig;\n  private isTriggered: boolean = false;\n  private isActive: boolean = true;\n  private triggerHistory: KillSwitchEvent[] = [];\n  private currentMode: 'normal' | 'recovery' | 'emergency' = 'normal';\n  private activeBots: Set<string> = new Set();\n  private consecutiveFailures: number = 0;\n  private dailyLoss: number = 0;\n  private currentDrawdown: number = 0;\n  private lastReset: Date = new Date();\n  private shutdownTimers: Map<string, NodeJS.Timeout> = new Map();\n\n  constructor(config: KillSwitchConfig) {\n    super();\n    this.validateConfig(config);\n    this.config = config;\n    this.setupDailyReset();\n    this.startHealthMonitoring();\n  }\n\n  /**\n   * Manually trigger the kill switch with reason\n   */\n  public async triggerKillSwitch(\n    reason: string, \n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high',\n    triggeredBy: 'user' | 'system' = 'user'\n  ): Promise<void> {\n    if (this.isTriggered) {\n      console.warn('Kill switch already triggered');\n      return;\n    }\n\n    const event: KillSwitchEvent = {\n      type: 'triggered',\n      timestamp: new Date().toISOString(),\n      reason,\n      triggeredBy,\n      severity,\n      metadata: {\n        activeBots: this.activeBots.size,\n        dailyLoss: this.dailyLoss,\n        currentDrawdown: this.currentDrawdown,\n        consecutiveFailures: this.consecutiveFailures\n      }\n    };\n\n    this.isTriggered = true;\n    this.currentMode = severity === 'critical' ? 'emergency' : 'recovery';\n    this.triggerHistory.push(event);\n\n    console.error(`ðŸš¨ KILL SWITCH TRIGGERED: ${reason}`);\n    console.error(`Severity: ${severity}, Mode: ${this.currentMode}`);\n\n    // Emit kill switch event\n    this.emit('kill-switch-triggered', event);\n\n    // Stop all bots based on severity\n    if (severity === 'critical') {\n      await this.forceStopAllBots();\n    } else {\n      await this.gracefulStopAllBots();\n    }\n\n    // Send emergency notifications\n    await this.sendEmergencyNotifications(event);\n\n    // Log the event\n    await this.logKillSwitchEvent(event);\n  }\n\n  /**\n   * Check if automatic trigger conditions are met\n   */\n  public checkAutoTriggerConditions(): void {\n    if (!this.config.enableAutoTrigger || this.isTriggered) {\n      return;\n    }\n\n    // Check daily loss limit\n    if (this.dailyLoss >= this.config.maxDailyLoss) {\n      this.triggerKillSwitch(\n        `Daily loss limit exceeded: $${this.dailyLoss.toFixed(2)}`,\n        'high',\n        'system'\n      );\n      return;\n    }\n\n    // Check maximum drawdown\n    if (this.currentDrawdown >= this.config.maxDrawdown) {\n      this.triggerKillSwitch(\n        `Maximum drawdown exceeded: ${this.currentDrawdown.toFixed(2)}%`,\n        'high',\n        'system'\n      );\n      return;\n    }\n\n    // Check consecutive failures\n    if (this.consecutiveFailures >= this.config.maxConsecutiveFailures) {\n      this.triggerKillSwitch(\n        `Too many consecutive failures: ${this.consecutiveFailures}`,\n        'medium',\n        'system'\n      );\n      return;\n    }\n  }\n\n  /**\n   * Register a bot with the kill switch\n   */\n  public registerBot(botId: string): void {\n    this.activeBots.add(botId);\n    this.emit('bot-registered', { botId, totalBots: this.activeBots.size });\n    \n    console.log(`Bot registered: ${botId} (Total: ${this.activeBots.size})`);\n  }\n\n  /**\n   * Unregister a bot from the kill switch\n   */\n  public unregisterBot(botId: string): void {\n    this.activeBots.delete(botId);\n    this.clearShutdownTimer(botId);\n    this.emit('bot-unregistered', { botId, totalBots: this.activeBots.size });\n    \n    console.log(`Bot unregistered: ${botId} (Total: ${this.activeBots.size})`);\n  }\n\n  /**\n   * Report a trade loss to track daily limits\n   */\n  public reportLoss(amount: number): void {\n    this.dailyLoss += amount;\n    this.emit('loss-reported', { amount, totalDailyLoss: this.dailyLoss });\n    \n    // Update drawdown calculation\n    this.updateDrawdown();\n    \n    // Check auto-trigger conditions\n    this.checkAutoTriggerConditions();\n  }\n\n  /**\n   * Report a consecutive failure\n   */\n  public reportFailure(botId: string, reason: string): void {\n    this.consecutiveFailures++;\n    this.emit('failure-reported', { \n      botId, \n      reason, \n      consecutiveFailures: this.consecutiveFailures \n    });\n    \n    console.warn(`Failure reported for ${botId}: ${reason} (${this.consecutiveFailures} consecutive)`);\n    \n    // Check auto-trigger conditions\n    this.checkAutoTriggerConditions();\n  }\n\n  /**\n   * Report a successful trade (resets consecutive failures)\n   */\n  public reportSuccess(botId: string): void {\n    this.consecutiveFailures = 0;\n    this.emit('success-reported', { botId });\n  }\n\n  /**\n   * Get current kill switch status\n   */\n  public getStatus(): KillSwitchStatus {\n    return {\n      isActive: this.isActive,\n      isTriggered: this.isTriggered,\n      lastTriggered: this.triggerHistory.length > 0 ? \n        this.triggerHistory[this.triggerHistory.length - 1].timestamp : undefined,\n      totalTriggers: this.triggerHistory.length,\n      currentMode: this.currentMode,\n      systemHealth: this.determineSystemHealth(),\n      activeBots: this.activeBots.size,\n      emergencyContact: this.config.emergencyContacts.length > 0\n    };\n  }\n\n  /**\n   * Reset the kill switch (must be done manually after investigation)\n   */\n  public async resetKillSwitch(reason: string, resetBy: string): Promise<void> {\n    if (!this.isTriggered) {\n      console.warn('Kill switch is not triggered, no reset needed');\n      return;\n    }\n\n    const event: KillSwitchEvent = {\n      type: 'recovery_mode',\n      timestamp: new Date().toISOString(),\n      reason: `Reset: ${reason}`,\n      triggeredBy: 'user',\n      severity: 'low',\n      metadata: { resetBy }\n    };\n\n    this.isTriggered = false;\n    this.currentMode = 'recovery';\n    this.triggerHistory.push(event);\n\n    console.log(`âœ… Kill switch reset: ${reason} (by ${resetBy})`);\n    \n    this.emit('kill-switch-reset', event);\n    await this.logKillSwitchEvent(event);\n\n    // Wait for manual confirmation before returning to normal mode\n    setTimeout(() => {\n      this.currentMode = 'normal';\n      this.emit('mode-changed', { mode: 'normal' });\n    }, 30000); // 30 second recovery period\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<KillSwitchConfig>): void {\n    const updatedConfig = { ...this.config, ...newConfig };\n    this.validateConfig(updatedConfig);\n    this.config = updatedConfig;\n    \n    this.emit('config-updated', updatedConfig);\n    console.log('Kill switch configuration updated');\n  }\n\n  /**\n   * Get kill switch history\n   */\n  public getHistory(limit: number = 50): KillSwitchEvent[] {\n    return this.triggerHistory.slice(-limit);\n  }\n\n  /**\n   * Check if kill switch is blocking bot operations\n   */\n  public isOperationAllowed(operation: 'start' | 'trade' | 'stop'): boolean {\n    if (!this.isActive) return false;\n    if (this.isTriggered && operation !== 'stop') return false;\n    if (this.currentMode === 'emergency' && operation !== 'stop') return false;\n    \n    return true;\n  }\n\n  // Private methods\n\n  private validateConfig(config: KillSwitchConfig): void {\n    const result = KillSwitchConfigSchema.safeParse(config);\n    if (!result.success) {\n      throw new Error(`Invalid kill switch configuration: ${result.error.message}`);\n    }\n  }\n\n  private async gracefulStopAllBots(): Promise<void> {\n    const stopPromises: Promise<void>[] = [];\n    \n    for (const botId of this.activeBots) {\n      const promise = this.gracefulStopBot(botId);\n      stopPromises.push(promise);\n    }\n\n    try {\n      await Promise.allSettled(stopPromises);\n      console.log('All bots gracefully stopped');\n    } catch (error) {\n      console.error('Error during graceful stop:', error);\n      // Force stop if graceful fails\n      await this.forceStopAllBots();\n    }\n  }\n\n  private async forceStopAllBots(): Promise<void> {\n    for (const botId of this.activeBots) {\n      this.emit('force-stop-bot', { botId });\n      this.unregisterBot(botId);\n    }\n    \n    console.log('All bots force stopped');\n  }\n\n  private async gracefulStopBot(botId: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Set graceful shutdown timer\n      const gracefulTimer = setTimeout(() => {\n        console.warn(`Graceful shutdown timeout for bot ${botId}, forcing stop`);\n        this.emit('force-stop-bot', { botId });\n        resolve();\n      }, this.config.gracefulShutdownTimeout);\n\n      this.shutdownTimers.set(botId, gracefulTimer);\n\n      // Emit graceful stop signal\n      this.emit('graceful-stop-bot', { \n        botId,\n        timeout: this.config.gracefulShutdownTimeout\n      });\n\n      // Set force shutdown timer\n      const forceTimer = setTimeout(() => {\n        this.clearShutdownTimer(botId);\n        this.emit('force-stop-bot', { botId });\n        resolve();\n      }, this.config.forceShutdownAfter);\n\n      // Listen for bot confirmation\n      const handleBotStopped = (event: { botId: string }) => {\n        if (event.botId === botId) {\n          this.clearShutdownTimer(botId);\n          clearTimeout(forceTimer);\n          this.off('bot-stopped', handleBotStopped);\n          resolve();\n        }\n      };\n\n      this.on('bot-stopped', handleBotStopped);\n    });\n  }\n\n  private clearShutdownTimer(botId: string): void {\n    const timer = this.shutdownTimers.get(botId);\n    if (timer) {\n      clearTimeout(timer);\n      this.shutdownTimers.delete(botId);\n    }\n  }\n\n  private updateDrawdown(): void {\n    // Simplified drawdown calculation - in production, this would use portfolio peak values\n    const dailyLossPercentage = (this.dailyLoss / 10000) * 100; // Assuming $10k base\n    this.currentDrawdown = Math.max(this.currentDrawdown, dailyLossPercentage);\n  }\n\n  private determineSystemHealth(): 'healthy' | 'degraded' | 'critical' {\n    if (this.isTriggered || this.currentMode === 'emergency') {\n      return 'critical';\n    }\n    \n    if (this.currentMode === 'recovery' || this.consecutiveFailures > 3) {\n      return 'degraded';\n    }\n    \n    return 'healthy';\n  }\n\n  private setupDailyReset(): void {\n    // Reset daily counters at midnight UTC\n    const now = new Date();\n    const tomorrow = new Date(now);\n    tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);\n    tomorrow.setUTCHours(0, 0, 0, 0);\n    \n    const timeUntilMidnight = tomorrow.getTime() - now.getTime();\n    \n    setTimeout(() => {\n      this.resetDailyCounters();\n      \n      // Set up recurring daily reset\n      setInterval(() => {\n        this.resetDailyCounters();\n      }, 24 * 60 * 60 * 1000);\n    }, timeUntilMidnight);\n  }\n\n  private resetDailyCounters(): void {\n    this.dailyLoss = 0;\n    this.currentDrawdown = 0;\n    this.lastReset = new Date();\n    \n    this.emit('daily-reset', { \n      timestamp: this.lastReset.toISOString() \n    });\n    \n    console.log('Daily risk counters reset');\n  }\n\n  private startHealthMonitoring(): void {\n    // Health check every 30 seconds\n    setInterval(() => {\n      this.emit('health-check', this.getStatus());\n    }, 30000);\n  }\n\n  private async sendEmergencyNotifications(event: KillSwitchEvent): Promise<void> {\n    // In production, this would send emails/SMS/Slack notifications\n    console.log('ðŸš¨ EMERGENCY NOTIFICATION:', {\n      contacts: this.config.emergencyContacts,\n      event\n    });\n    \n    // Emit notification event for external handlers\n    this.emit('emergency-notification', {\n      event,\n      contacts: this.config.emergencyContacts\n    });\n  }\n\n  private async logKillSwitchEvent(event: KillSwitchEvent): Promise<void> {\n    // In production, this would log to database/monitoring system\n    console.log('Kill switch event logged:', event);\n    \n    // Emit for external logging systems\n    this.emit('event-logged', event);\n  }\n\n  /**\n   * Cleanup resources\n   */\n  public destroy(): void {\n    // Clear all timers\n    for (const timer of this.shutdownTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.shutdownTimers.clear();\n    \n    // Remove all listeners\n    this.removeAllListeners();\n    \n    console.log('Kill switch destroyed');\n  }\n}","import { z } from 'zod';\n\nexport interface PositionSizingConfig {\n  baseRiskPerTrade: number; // Percentage of portfolio to risk per trade (0-5%)\n  maxPositionSize: number; // Maximum position size as % of portfolio\n  minPositionSize: number; // Minimum position size in USD\n  volatilityLookback: number; // Days to look back for volatility calculation\n  maxDailyRisk: number; // Maximum daily risk exposure as % of portfolio\n  correlationThreshold: number; // Maximum correlation between positions (0-1)\n  riskScalingMethod: 'fixed' | 'volatility' | 'kelly' | 'adaptive';\n  enableDynamicSizing: boolean;\n}\n\nexport interface MarketData {\n  price: number;\n  volume24h: number;\n  volatility: number; // Annualized volatility\n  liquidity: number; // Depth of order book\n  spread: number; // Bid-ask spread as percentage\n  timestamp: string;\n}\n\nexport interface TradeSignal {\n  direction: 'long' | 'short';\n  confidence: number; // 0-1 confidence score\n  expectedReturn: number; // Expected return percentage\n  timeHorizon: number; // Expected holding time in hours\n  riskReward: number; // Risk-reward ratio\n}\n\nexport interface PositionResult {\n  positionSize: number; // Position size in USD\n  riskAmount: number; // Amount at risk in USD\n  leverage: number; // Effective leverage used\n  stopLoss: number; // Recommended stop loss price\n  takeProfit: number; // Recommended take profit price\n  reasoning: string; // Explanation of sizing decision\n  riskMetrics: {\n    portfolioRisk: number; // Percentage of portfolio at risk\n    dailyVaR: number; // Daily Value at Risk\n    sharpeContribution: number; // Expected Sharpe ratio contribution\n    maxDrawdownContribution: number; // Expected max drawdown contribution\n  };\n}\n\nexport interface PortfolioRisk {\n  totalRisk: number; // Total portfolio risk exposure\n  dailyRisk: number; // Current daily risk exposure\n  concentration: number; // Concentration risk score\n  correlation: number; // Average correlation between positions\n  leverage: number; // Portfolio leverage\n  liquidityRisk: number; // Liquidity risk score\n}\n\nconst PositionSizingConfigSchema = z.object({\n  baseRiskPerTrade: z.number().min(0.1).max(10),\n  maxPositionSize: z.number().min(1).max(50),\n  minPositionSize: z.number().positive(),\n  volatilityLookback: z.number().min(1).max(90),\n  maxDailyRisk: z.number().min(1).max(20),\n  correlationThreshold: z.number().min(0).max(1),\n  riskScalingMethod: z.enum(['fixed', 'volatility', 'kelly', 'adaptive']),\n  enableDynamicSizing: z.boolean()\n});\n\nexport class PositionSizingEngine {\n  private config: PositionSizingConfig;\n  private portfolioValue: number;\n  private currentPositions: Map<string, any> = new Map();\n  private historicalReturns: number[] = [];\n  private volatilityCache: Map<string, number> = new Map();\n\n  constructor(config: PositionSizingConfig, portfolioValue: number) {\n    this.validateConfig(config);\n    this.config = config;\n    this.portfolioValue = portfolioValue;\n  }\n\n  /**\n   * Calculate optimal position size for a trade signal\n   */\n  public calculatePositionSize(\n    symbol: string,\n    signal: TradeSignal,\n    marketData: MarketData,\n    portfolioRisk: PortfolioRisk\n  ): PositionResult {\n    // Step 1: Calculate base position size using selected method\n    let baseSize = this.calculateBaseSize(signal, marketData);\n\n    // Step 2: Apply risk adjustments\n    const volatilityAdjustment = this.calculateVolatilityAdjustment(marketData);\n    const liquidityAdjustment = this.calculateLiquidityAdjustment(marketData);\n    const correlationAdjustment = this.calculateCorrelationAdjustment(symbol, portfolioRisk);\n    const portfolioRiskAdjustment = this.calculatePortfolioRiskAdjustment(portfolioRisk);\n\n    // Step 3: Combine all adjustments\n    const adjustedSize = baseSize * \n      volatilityAdjustment * \n      liquidityAdjustment * \n      correlationAdjustment * \n      portfolioRiskAdjustment;\n\n    // Step 4: Apply position limits\n    const finalSize = this.applyPositionLimits(adjustedSize, portfolioRisk);\n\n    // Step 5: Calculate risk metrics and levels\n    const riskAmount = this.calculateRiskAmount(finalSize, signal, marketData);\n    const stopLoss = this.calculateStopLoss(marketData.price, signal, riskAmount, finalSize);\n    const takeProfit = this.calculateTakeProfit(marketData.price, signal);\n    const leverage = finalSize / (this.portfolioValue * (this.config.baseRiskPerTrade / 100));\n\n    // Step 6: Calculate risk metrics\n    const riskMetrics = this.calculateRiskMetrics(finalSize, riskAmount, signal, marketData);\n\n    // Step 7: Generate reasoning\n    const reasoning = this.generateReasoning(\n      baseSize, \n      adjustedSize, \n      finalSize, \n      {\n        volatilityAdjustment,\n        liquidityAdjustment,\n        correlationAdjustment,\n        portfolioRiskAdjustment\n      }\n    );\n\n    return {\n      positionSize: Math.round(finalSize * 100) / 100,\n      riskAmount: Math.round(riskAmount * 100) / 100,\n      leverage: Math.round(leverage * 100) / 100,\n      stopLoss: Math.round(stopLoss * 100) / 100,\n      takeProfit: Math.round(takeProfit * 100) / 100,\n      reasoning,\n      riskMetrics\n    };\n  }\n\n  /**\n   * Calculate base position size using configured method\n   */\n  private calculateBaseSize(signal: TradeSignal, marketData: MarketData): number {\n    const baseRiskAmount = this.portfolioValue * (this.config.baseRiskPerTrade / 100);\n\n    switch (this.config.riskScalingMethod) {\n      case 'fixed':\n        return baseRiskAmount;\n\n      case 'volatility':\n        // Inverse volatility scaling\n        const normalizedVol = Math.max(0.1, Math.min(2.0, marketData.volatility / 0.3));\n        return baseRiskAmount / normalizedVol;\n\n      case 'kelly':\n        return this.calculateKellySize(signal, marketData, baseRiskAmount);\n\n      case 'adaptive':\n        return this.calculateAdaptiveSize(signal, marketData, baseRiskAmount);\n\n      default:\n        return baseRiskAmount;\n    }\n  }\n\n  /**\n   * Kelly criterion position sizing\n   */\n  private calculateKellySize(signal: TradeSignal, marketData: MarketData, baseAmount: number): number {\n    const winProbability = signal.confidence;\n    const avgWin = signal.expectedReturn;\n    const avgLoss = -signal.expectedReturn / signal.riskReward; // Assuming risk-reward ratio\n\n    // Kelly fraction: (bp - q) / b\n    // where b = odds received (avgWin/avgLoss), p = probability of win, q = probability of loss\n    const b = Math.abs(avgWin / avgLoss);\n    const kellyFraction = (b * winProbability - (1 - winProbability)) / b;\n\n    // Apply Kelly fraction with safety margin (25% of optimal)\n    const safeKellyFraction = Math.max(0, Math.min(0.25, kellyFraction * 0.25));\n    \n    return this.portfolioValue * safeKellyFraction;\n  }\n\n  /**\n   * Adaptive position sizing based on recent performance\n   */\n  private calculateAdaptiveSize(signal: TradeSignal, marketData: MarketData, baseAmount: number): number {\n    // Adjust based on recent win rate and Sharpe ratio\n    const recentPerformance = this.calculateRecentPerformance();\n    const performanceMultiplier = Math.max(0.5, Math.min(2.0, recentPerformance));\n    \n    // Adjust based on signal confidence\n    const confidenceMultiplier = 0.5 + (signal.confidence * 0.5);\n    \n    return baseAmount * performanceMultiplier * confidenceMultiplier;\n  }\n\n  /**\n   * Calculate volatility adjustment factor\n   */\n  private calculateVolatilityAdjustment(marketData: MarketData): number {\n    // Reduce position size in high volatility environments\n    const normalizedVol = marketData.volatility / 0.3; // Normalize to 30% baseline\n    return Math.max(0.2, Math.min(2.0, 1 / Math.sqrt(normalizedVol)));\n  }\n\n  /**\n   * Calculate liquidity adjustment factor\n   */\n  private calculateLiquidityAdjustment(marketData: MarketData): number {\n    // Reduce position size for illiquid markets\n    const spreadPenalty = Math.max(0.5, 1 - (marketData.spread * 10));\n    const volumeBonus = Math.min(1.2, Math.sqrt(marketData.volume24h / 1000000)); // Normalize to $1M baseline\n    \n    return spreadPenalty * volumeBonus;\n  }\n\n  /**\n   * Calculate correlation adjustment factor\n   */\n  private calculateCorrelationAdjustment(symbol: string, portfolioRisk: PortfolioRisk): number {\n    // Reduce position size if portfolio is highly correlated\n    if (portfolioRisk.correlation > this.config.correlationThreshold) {\n      const correlationPenalty = 1 - (portfolioRisk.correlation - this.config.correlationThreshold);\n      return Math.max(0.3, correlationPenalty);\n    }\n    \n    return 1.0;\n  }\n\n  /**\n   * Calculate portfolio risk adjustment factor\n   */\n  private calculatePortfolioRiskAdjustment(portfolioRisk: PortfolioRisk): number {\n    // Reduce position size if portfolio risk is already high\n    const riskUtilization = portfolioRisk.dailyRisk / this.config.maxDailyRisk;\n    \n    if (riskUtilization > 0.8) {\n      return Math.max(0.1, 1 - riskUtilization);\n    }\n    \n    return 1.0;\n  }\n\n  /**\n   * Apply position size limits\n   */\n  private applyPositionLimits(size: number, portfolioRisk: PortfolioRisk): number {\n    // Apply minimum position size\n    const minSize = Math.max(this.config.minPositionSize, size);\n    \n    // Apply maximum position size\n    const maxSize = this.portfolioValue * (this.config.maxPositionSize / 100);\n    const limitedSize = Math.min(minSize, maxSize);\n    \n    // Ensure we don't exceed daily risk limits\n    const remainingDailyRisk = this.config.maxDailyRisk - portfolioRisk.dailyRisk;\n    const maxDailyRiskSize = this.portfolioValue * (remainingDailyRisk / 100);\n    \n    return Math.min(limitedSize, maxDailyRiskSize);\n  }\n\n  /**\n   * Calculate risk amount for position\n   */\n  private calculateRiskAmount(positionSize: number, signal: TradeSignal, marketData: MarketData): number {\n    // Risk amount based on expected volatility and stop loss distance\n    const stopLossDistance = this.calculateStopLossDistance(signal, marketData);\n    return positionSize * stopLossDistance;\n  }\n\n  /**\n   * Calculate optimal stop loss price\n   */\n  private calculateStopLoss(price: number, signal: TradeSignal, riskAmount: number, positionSize: number): number {\n    const stopLossDistance = riskAmount / positionSize;\n    \n    if (signal.direction === 'long') {\n      return price * (1 - stopLossDistance);\n    } else {\n      return price * (1 + stopLossDistance);\n    }\n  }\n\n  /**\n   * Calculate take profit price\n   */\n  private calculateTakeProfit(price: number, signal: TradeSignal): number {\n    const targetReturn = signal.expectedReturn;\n    \n    if (signal.direction === 'long') {\n      return price * (1 + targetReturn);\n    } else {\n      return price * (1 - targetReturn);\n    }\n  }\n\n  /**\n   * Calculate stop loss distance based on volatility and signal\n   */\n  private calculateStopLossDistance(signal: TradeSignal, marketData: MarketData): number {\n    // Base stop loss on volatility and confidence\n    const volatilityStop = marketData.volatility * Math.sqrt(1/252); // Daily volatility\n    const confidenceAdjustment = 1 + (1 - signal.confidence); // Wider stops for low confidence\n    \n    return Math.min(0.1, volatilityStop * confidenceAdjustment * 2); // Max 10% stop loss\n  }\n\n  /**\n   * Calculate comprehensive risk metrics\n   */\n  private calculateRiskMetrics(\n    positionSize: number, \n    riskAmount: number, \n    signal: TradeSignal, \n    marketData: MarketData\n  ): PositionResult['riskMetrics'] {\n    const portfolioRisk = (riskAmount / this.portfolioValue) * 100;\n    const dailyVaR = this.calculateDailyVaR(positionSize, marketData);\n    const sharpeContribution = this.calculateSharpeContribution(signal, positionSize);\n    const maxDrawdownContribution = this.calculateMaxDrawdownContribution(riskAmount);\n\n    return {\n      portfolioRisk: Math.round(portfolioRisk * 100) / 100,\n      dailyVaR: Math.round(dailyVaR * 100) / 100,\n      sharpeContribution: Math.round(sharpeContribution * 1000) / 1000,\n      maxDrawdownContribution: Math.round(maxDrawdownContribution * 100) / 100\n    };\n  }\n\n  /**\n   * Calculate daily Value at Risk\n   */\n  private calculateDailyVaR(positionSize: number, marketData: MarketData): number {\n    // 95% VaR using normal distribution assumption\n    const dailyVol = marketData.volatility * Math.sqrt(1/252);\n    return positionSize * dailyVol * 1.645; // 95% confidence level\n  }\n\n  /**\n   * Calculate expected Sharpe ratio contribution\n   */\n  private calculateSharpeContribution(signal: TradeSignal, positionSize: number): number {\n    const weight = positionSize / this.portfolioValue;\n    const expectedReturn = signal.expectedReturn * signal.confidence;\n    const riskFreeRate = 0.02; // Assume 2% risk-free rate\n    \n    return weight * (expectedReturn - riskFreeRate);\n  }\n\n  /**\n   * Calculate maximum drawdown contribution\n   */\n  private calculateMaxDrawdownContribution(riskAmount: number): number {\n    // Simplified: assume worst case scenario\n    return (riskAmount / this.portfolioValue) * 100;\n  }\n\n  /**\n   * Calculate recent performance for adaptive sizing\n   */\n  private calculateRecentPerformance(): number {\n    if (this.historicalReturns.length < 10) {\n      return 1.0; // Default multiplier\n    }\n\n    const recentReturns = this.historicalReturns.slice(-20); // Last 20 trades\n    const winRate = recentReturns.filter(r => r > 0).length / recentReturns.length;\n    const avgReturn = recentReturns.reduce((sum, r) => sum + r, 0) / recentReturns.length;\n\n    // Combine win rate and average return\n    return (winRate * 0.6) + (Math.max(-0.5, Math.min(0.5, avgReturn * 10)) * 0.4) + 0.5;\n  }\n\n  /**\n   * Generate human-readable reasoning for position sizing decision\n   */\n  private generateReasoning(\n    baseSize: number, \n    adjustedSize: number, \n    finalSize: number,\n    adjustments: {\n      volatilityAdjustment: number;\n      liquidityAdjustment: number;\n      correlationAdjustment: number;\n      portfolioRiskAdjustment: number;\n    }\n  ): string {\n    const reasons: string[] = [];\n\n    reasons.push(`Base size: $${baseSize.toFixed(0)} (${this.config.riskScalingMethod} method)`);\n\n    if (Math.abs(adjustments.volatilityAdjustment - 1) > 0.1) {\n      const change = adjustments.volatilityAdjustment > 1 ? 'increased' : 'reduced';\n      reasons.push(`${change} by ${Math.abs(adjustments.volatilityAdjustment - 1).toFixed(1)}x for volatility`);\n    }\n\n    if (Math.abs(adjustments.liquidityAdjustment - 1) > 0.1) {\n      const change = adjustments.liquidityAdjustment > 1 ? 'increased' : 'reduced';\n      reasons.push(`${change} by ${Math.abs(adjustments.liquidityAdjustment - 1).toFixed(1)}x for liquidity`);\n    }\n\n    if (Math.abs(adjustments.correlationAdjustment - 1) > 0.1) {\n      reasons.push(`reduced by ${(1 - adjustments.correlationAdjustment).toFixed(1)}x for correlation risk`);\n    }\n\n    if (Math.abs(adjustments.portfolioRiskAdjustment - 1) > 0.1) {\n      reasons.push(`reduced by ${(1 - adjustments.portfolioRiskAdjustment).toFixed(1)}x for portfolio risk`);\n    }\n\n    if (finalSize !== adjustedSize) {\n      reasons.push(`limited to $${finalSize.toFixed(0)} by position/risk limits`);\n    }\n\n    return reasons.join(', ');\n  }\n\n  /**\n   * Add trade result for adaptive sizing\n   */\n  public addTradeResult(returnPct: number): void {\n    this.historicalReturns.push(returnPct);\n    \n    // Keep only last 100 trades\n    if (this.historicalReturns.length > 100) {\n      this.historicalReturns = this.historicalReturns.slice(-100);\n    }\n  }\n\n  /**\n   * Update portfolio value\n   */\n  public updatePortfolioValue(newValue: number): void {\n    this.portfolioValue = newValue;\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<PositionSizingConfig>): void {\n    const updatedConfig = { ...this.config, ...newConfig };\n    this.validateConfig(updatedConfig);\n    this.config = updatedConfig;\n  }\n\n  /**\n   * Get current configuration\n   */\n  public getConfig(): PositionSizingConfig {\n    return { ...this.config };\n  }\n\n  private validateConfig(config: PositionSizingConfig): void {\n    const result = PositionSizingConfigSchema.safeParse(config);\n    if (!result.success) {\n      throw new Error(`Invalid position sizing configuration: ${result.error.message}`);\n    }\n  }\n}","import EventEmitter from 'eventemitter3';\nimport { GlobalKillSwitch, KillSwitchConfig, KillSwitchStatus } from './global-kill-switch';\nimport { PositionSizingEngine, PositionSizingConfig, PositionResult, PortfolioRisk, TradeSignal, MarketData } from './position-sizing';\n\nexport interface RiskManagerConfig {\n  killSwitch: KillSwitchConfig;\n  positionSizing: PositionSizingConfig;\n  portfolioLimits: {\n    maxPortfolioRisk: number; // Maximum portfolio risk percentage\n    maxSectorConcentration: number; // Maximum concentration in single sector\n    maxCorrelation: number; // Maximum correlation between positions\n    rebalanceThreshold: number; // Trigger rebalancing when exceeded\n  };\n  stressTest: {\n    enabled: boolean;\n    scenarios: StressTestScenario[];\n    failureThreshold: number; // Max acceptable loss in stress test\n  };\n}\n\nexport interface StressTestScenario {\n  name: string;\n  description: string;\n  marketShock: number; // Market down percentage\n  volatilityMultiplier: number; // Volatility increase factor\n  liquidityReduction: number; // Liquidity reduction percentage\n  correlationIncrease: number; // Correlation increase in crisis\n}\n\nexport interface Position {\n  id: string;\n  symbol: string;\n  size: number; // Position size in USD\n  entryPrice: number;\n  currentPrice: number;\n  direction: 'long' | 'short';\n  pnl: number; // Current P&L\n  riskAmount: number; // Amount at risk\n  sector?: string;\n  timestamp: string;\n}\n\nexport interface RiskReport {\n  timestamp: string;\n  portfolioRisk: PortfolioRisk;\n  killSwitchStatus: KillSwitchStatus;\n  stressTestResults?: StressTestResult[];\n  recommendations: RiskRecommendation[];\n  alerts: RiskAlert[];\n}\n\nexport interface StressTestResult {\n  scenario: string;\n  expectedLoss: number;\n  worstCaseVaR: number;\n  timeToRecovery: number; // Estimated days to recover\n  passed: boolean;\n}\n\nexport interface RiskRecommendation {\n  type: 'reduce_position' | 'hedge' | 'rebalance' | 'diversify' | 'increase_cash';\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n  expectedImpact: string;\n  positions?: string[]; // Affected position IDs\n}\n\nexport interface RiskAlert {\n  id: string;\n  type: 'risk_limit' | 'correlation' | 'concentration' | 'drawdown' | 'stress_test' | 'emergency_stop';\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  message: string;\n  timestamp: string;\n  acknowledged: boolean;\n  positions?: string[];\n}\n\nexport class RiskManager extends EventEmitter {\n  private killSwitch: GlobalKillSwitch;\n  private positionSizing: PositionSizingEngine;\n  private config: RiskManagerConfig;\n  private positions: Map<string, Position> = new Map();\n  private portfolioValue: number;\n  private alerts: Map<string, RiskAlert> = new Map();\n  private lastStressTest: Date = new Date();\n  private riskReports: RiskReport[] = [];\n\n  constructor(config: RiskManagerConfig, portfolioValue: number) {\n    super();\n    this.config = config;\n    this.portfolioValue = portfolioValue;\n    \n    // Initialize components\n    this.killSwitch = new GlobalKillSwitch(config.killSwitch);\n    this.positionSizing = new PositionSizingEngine(config.positionSizing, portfolioValue);\n    \n    this.setupEventListeners();\n    this.startRiskMonitoring();\n  }\n\n  /**\n   * Calculate position size for a new trade\n   */\n  public calculatePositionSize(\n    symbol: string,\n    signal: TradeSignal,\n    marketData: MarketData\n  ): PositionResult {\n    // Check if operations are allowed\n    if (!this.killSwitch.isOperationAllowed('trade')) {\n      throw new Error('Trading operations are blocked by kill switch');\n    }\n\n    // Calculate current portfolio risk\n    const portfolioRisk = this.calculatePortfolioRisk();\n    \n    // Check portfolio risk limits\n    if (portfolioRisk.totalRisk > this.config.portfolioLimits.maxPortfolioRisk) {\n      throw new Error(`Portfolio risk (${portfolioRisk.totalRisk.toFixed(2)}%) exceeds limit (${this.config.portfolioLimits.maxPortfolioRisk}%)`);\n    }\n\n    // Calculate position size\n    const positionResult = this.positionSizing.calculatePositionSize(\n      symbol,\n      signal,\n      marketData,\n      portfolioRisk\n    );\n\n    // Validate position against portfolio limits\n    this.validateNewPosition(symbol, positionResult, portfolioRisk);\n\n    return positionResult;\n  }\n\n  /**\n   * Add a new position to the portfolio\n   */\n  public addPosition(position: Position): void {\n    this.positions.set(position.id, position);\n    this.killSwitch.registerBot(position.id);\n    \n    this.emit('position-added', position);\n    \n    // Run risk checks\n    this.checkRiskLimits();\n    this.generateRiskReport();\n  }\n\n  /**\n   * Update an existing position\n   */\n  public updatePosition(positionId: string, updates: Partial<Position>): void {\n    const position = this.positions.get(positionId);\n    if (!position) {\n      throw new Error(`Position ${positionId} not found`);\n    }\n\n    const updatedPosition = { ...position, ...updates };\n    this.positions.set(positionId, updatedPosition);\n    \n    this.emit('position-updated', updatedPosition);\n    \n    // Check if position needs attention\n    this.checkPositionRisk(updatedPosition);\n  }\n\n  /**\n   * Remove a position from the portfolio\n   */\n  public removePosition(positionId: string): void {\n    const position = this.positions.get(positionId);\n    if (position) {\n      this.positions.delete(positionId);\n      this.killSwitch.unregisterBot(positionId);\n      \n      this.emit('position-removed', position);\n      \n      // Update portfolio metrics\n      this.generateRiskReport();\n    }\n  }\n\n  /**\n   * Report a trade result for risk tracking\n   */\n  public reportTradeResult(positionId: string, pnl: number, success: boolean): void {\n    const position = this.positions.get(positionId);\n    if (!position) return;\n\n    const returnPct = pnl / position.size;\n    \n    // Update position sizing engine\n    this.positionSizing.addTradeResult(returnPct);\n    \n    // Report to kill switch\n    if (success) {\n      this.killSwitch.reportSuccess(positionId);\n    } else {\n      this.killSwitch.reportFailure(positionId, `Trade loss: ${pnl.toFixed(2)}`);\n    }\n    \n    // Track losses for kill switch\n    if (pnl < 0) {\n      this.killSwitch.reportLoss(Math.abs(pnl));\n    }\n    \n    this.emit('trade-result', { positionId, pnl, success, returnPct });\n  }\n\n  /**\n   * Get current portfolio risk assessment\n   */\n  public getPortfolioRisk(): PortfolioRisk {\n    return this.calculatePortfolioRisk();\n  }\n\n  /**\n   * Generate comprehensive risk report\n   */\n  public generateRiskReport(): RiskReport {\n    const timestamp = new Date().toISOString();\n    const portfolioRisk = this.calculatePortfolioRisk();\n    const killSwitchStatus = this.killSwitch.getStatus();\n    \n    // Run stress tests if needed\n    let stressTestResults: StressTestResult[] | undefined;\n    if (this.shouldRunStressTest()) {\n      stressTestResults = this.runStressTests();\n    }\n    \n    // Generate recommendations\n    const recommendations = this.generateRecommendations(portfolioRisk, stressTestResults);\n    \n    // Get current alerts\n    const alerts = Array.from(this.alerts.values());\n    \n    const report: RiskReport = {\n      timestamp,\n      portfolioRisk,\n      killSwitchStatus,\n      stressTestResults,\n      recommendations,\n      alerts\n    };\n    \n    this.riskReports.push(report);\n    \n    // Keep only last 100 reports\n    if (this.riskReports.length > 100) {\n      this.riskReports = this.riskReports.slice(-100);\n    }\n    \n    this.emit('risk-report-generated', report);\n    \n    return report;\n  }\n\n  /**\n   * Trigger emergency risk controls\n   */\n  public async triggerEmergencyStop(reason: string): Promise<void> {\n    await this.killSwitch.triggerKillSwitch(reason, 'critical', 'user');\n    \n    // Close all positions if possible\n    for (const position of this.positions.values()) {\n      this.emit('emergency-close-position', position);\n    }\n    \n    this.createAlert('emergency_stop', 'critical', `Emergency stop triggered: ${reason}`, []);\n  }\n\n  /**\n   * Get historical risk reports\n   */\n  public getRiskHistory(days: number = 30): RiskReport[] {\n    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n    return this.riskReports.filter(report => \n      new Date(report.timestamp) >= cutoffDate\n    );\n  }\n\n  /**\n   * Update portfolio value\n   */\n  public updatePortfolioValue(newValue: number): void {\n    this.portfolioValue = newValue;\n    this.positionSizing.updatePortfolioValue(newValue);\n    \n    this.emit('portfolio-value-updated', newValue);\n  }\n\n  /**\n   * Acknowledge a risk alert\n   */\n  public acknowledgeAlert(alertId: string): void {\n    const alert = this.alerts.get(alertId);\n    if (alert) {\n      alert.acknowledged = true;\n      this.emit('alert-acknowledged', alert);\n    }\n  }\n\n  // Private methods\n\n  private setupEventListeners(): void {\n    // Listen to kill switch events\n    this.killSwitch.on('kill-switch-triggered', (event) => {\n      this.emit('kill-switch-triggered', event);\n      this.createAlert('risk_limit', 'critical', `Kill switch triggered: ${event.reason}`, []);\n    });\n\n    this.killSwitch.on('emergency-notification', (data) => {\n      this.emit('emergency-notification', data);\n    });\n  }\n\n  private startRiskMonitoring(): void {\n    // Risk monitoring every 30 seconds\n    setInterval(() => {\n      this.checkRiskLimits();\n      this.generateRiskReport();\n    }, 30000);\n\n    // Daily stress tests\n    setInterval(() => {\n      if (this.shouldRunStressTest()) {\n        this.runStressTests();\n      }\n    }, 60 * 60 * 1000); // Check every hour\n  }\n\n  private calculatePortfolioRisk(): PortfolioRisk {\n    const positions = Array.from(this.positions.values());\n    \n    if (positions.length === 0) {\n      return {\n        totalRisk: 0,\n        dailyRisk: 0,\n        concentration: 0,\n        correlation: 0,\n        leverage: 0,\n        liquidityRisk: 0\n      };\n    }\n\n    const totalValue = positions.reduce((sum, pos) => sum + Math.abs(pos.size), 0);\n    const totalRisk = positions.reduce((sum, pos) => sum + pos.riskAmount, 0);\n    const totalPnL = positions.reduce((sum, pos) => sum + pos.pnl, 0);\n\n    // Calculate concentration risk (largest position)\n    const maxPosition = Math.max(...positions.map(pos => Math.abs(pos.size)));\n    const concentration = (maxPosition / this.portfolioValue) * 100;\n\n    // Simplified correlation calculation\n    const correlation = this.calculateAverageCorrelation(positions);\n\n    // Calculate leverage\n    const leverage = totalValue / this.portfolioValue;\n\n    // Daily risk as percentage of portfolio\n    const dailyRisk = (Math.abs(totalPnL) / this.portfolioValue) * 100;\n\n    // Simplified liquidity risk\n    const liquidityRisk = Math.min(100, positions.length * 5); // More positions = higher liquidity risk\n\n    return {\n      totalRisk: (totalRisk / this.portfolioValue) * 100,\n      dailyRisk,\n      concentration,\n      correlation,\n      leverage,\n      liquidityRisk\n    };\n  }\n\n  private calculateAverageCorrelation(positions: Position[]): number {\n    // Simplified correlation calculation\n    // In production, this would use actual price correlation data\n    const sectors = new Set(positions.map(pos => pos.sector || 'unknown'));\n    const maxSectorCount = Math.max(...Array.from(sectors).map(sector => \n      positions.filter(pos => (pos.sector || 'unknown') === sector).length\n    ));\n    \n    return Math.min(1, maxSectorCount / positions.length);\n  }\n\n  private checkRiskLimits(): void {\n    const portfolioRisk = this.calculatePortfolioRisk();\n    \n    // Check portfolio risk limit\n    if (portfolioRisk.totalRisk > this.config.portfolioLimits.maxPortfolioRisk) {\n      this.createAlert(\n        'risk_limit',\n        'error',\n        `Portfolio risk (${portfolioRisk.totalRisk.toFixed(2)}%) exceeds limit (${this.config.portfolioLimits.maxPortfolioRisk}%)`,\n        []\n      );\n    }\n    \n    // Check concentration limit\n    if (portfolioRisk.concentration > this.config.portfolioLimits.maxSectorConcentration) {\n      this.createAlert(\n        'concentration',\n        'warning',\n        `Position concentration (${portfolioRisk.concentration.toFixed(2)}%) exceeds limit (${this.config.portfolioLimits.maxSectorConcentration}%)`,\n        []\n      );\n    }\n    \n    // Check correlation limit\n    if (portfolioRisk.correlation > this.config.portfolioLimits.maxCorrelation) {\n      this.createAlert(\n        'correlation',\n        'warning',\n        `Portfolio correlation (${portfolioRisk.correlation.toFixed(2)}) exceeds limit (${this.config.portfolioLimits.maxCorrelation})`,\n        []\n      );\n    }\n  }\n\n  private checkPositionRisk(position: Position): void {\n    // Check individual position drawdown\n    const drawdown = ((position.entryPrice - position.currentPrice) / position.entryPrice) * 100;\n    const absDrawdown = Math.abs(drawdown);\n    \n    if (absDrawdown > 20) { // 20% drawdown threshold\n      this.createAlert(\n        'drawdown',\n        'error',\n        `Position ${position.symbol} has ${absDrawdown.toFixed(2)}% drawdown`,\n        [position.id]\n      );\n    }\n  }\n\n  private validateNewPosition(symbol: string, positionResult: PositionResult, portfolioRisk: PortfolioRisk): void {\n    // Check if new position would exceed concentration limits\n    const newConcentration = (positionResult.positionSize / this.portfolioValue) * 100;\n    if (newConcentration > this.config.portfolioLimits.maxSectorConcentration) {\n      throw new Error(`Position size would exceed concentration limit: ${newConcentration.toFixed(2)}% > ${this.config.portfolioLimits.maxSectorConcentration}%`);\n    }\n    \n    // Check total portfolio risk after new position\n    const newTotalRisk = portfolioRisk.totalRisk + positionResult.riskMetrics.portfolioRisk;\n    if (newTotalRisk > this.config.portfolioLimits.maxPortfolioRisk) {\n      throw new Error(`New position would exceed portfolio risk limit: ${newTotalRisk.toFixed(2)}% > ${this.config.portfolioLimits.maxPortfolioRisk}%`);\n    }\n  }\n\n  private shouldRunStressTest(): boolean {\n    if (!this.config.stressTest.enabled) return false;\n    \n    const daysSinceLastTest = (Date.now() - this.lastStressTest.getTime()) / (1000 * 60 * 60 * 24);\n    return daysSinceLastTest >= 1; // Run daily\n  }\n\n  private runStressTests(): StressTestResult[] {\n    this.lastStressTest = new Date();\n    \n    const results: StressTestResult[] = [];\n    const positions = Array.from(this.positions.values());\n    \n    for (const scenario of this.config.stressTest.scenarios) {\n      const result = this.runSingleStressTest(scenario, positions);\n      results.push(result);\n      \n      if (!result.passed) {\n        this.createAlert(\n          'stress_test',\n          'error',\n          `Stress test failed: ${scenario.name} - Expected loss: ${result.expectedLoss.toFixed(2)}%`,\n          []\n        );\n      }\n    }\n    \n    this.emit('stress-test-completed', results);\n    return results;\n  }\n\n  private runSingleStressTest(scenario: StressTestScenario, positions: Position[]): StressTestResult {\n    let totalLoss = 0;\n    let worstCaseVaR = 0;\n    \n    for (const position of positions) {\n      // Simulate price shock\n      const priceShock = scenario.marketShock / 100;\n      const shockPrice = position.direction === 'long' ? \n        position.currentPrice * (1 + priceShock) : \n        position.currentPrice * (1 - priceShock);\n      \n      const pnl = position.direction === 'long' ?\n        (shockPrice - position.entryPrice) * (position.size / position.entryPrice) :\n        (position.entryPrice - shockPrice) * (position.size / position.entryPrice);\n      \n      totalLoss += Math.abs(pnl);\n      worstCaseVaR += Math.abs(pnl) * scenario.volatilityMultiplier;\n    }\n    \n    const lossPercentage = (totalLoss / this.portfolioValue) * 100;\n    const varPercentage = (worstCaseVaR / this.portfolioValue) * 100;\n    const passed = lossPercentage <= this.config.stressTest.failureThreshold;\n    \n    return {\n      scenario: scenario.name,\n      expectedLoss: lossPercentage,\n      worstCaseVaR: varPercentage,\n      timeToRecovery: Math.ceil(lossPercentage / 2), // Simplified: 2% recovery per day\n      passed\n    };\n  }\n\n  private generateRecommendations(portfolioRisk: PortfolioRisk, stressTestResults?: StressTestResult[]): RiskRecommendation[] {\n    const recommendations: RiskRecommendation[] = [];\n    \n    // Portfolio risk recommendations\n    if (portfolioRisk.totalRisk > this.config.portfolioLimits.maxPortfolioRisk * 0.8) {\n      recommendations.push({\n        type: 'reduce_position',\n        priority: 'high',\n        description: 'Consider reducing position sizes to lower portfolio risk',\n        expectedImpact: `Reduce portfolio risk from ${portfolioRisk.totalRisk.toFixed(2)}% to below ${this.config.portfolioLimits.maxPortfolioRisk}%`\n      });\n    }\n    \n    // Concentration recommendations\n    if (portfolioRisk.concentration > this.config.portfolioLimits.maxSectorConcentration * 0.8) {\n      recommendations.push({\n        type: 'diversify',\n        priority: 'medium',\n        description: 'Portfolio is becoming concentrated, consider diversifying',\n        expectedImpact: `Reduce concentration risk from ${portfolioRisk.concentration.toFixed(2)}%`\n      });\n    }\n    \n    // Correlation recommendations\n    if (portfolioRisk.correlation > this.config.portfolioLimits.maxCorrelation * 0.8) {\n      recommendations.push({\n        type: 'hedge',\n        priority: 'medium',\n        description: 'High correlation detected, consider hedging strategies',\n        expectedImpact: `Reduce correlation from ${portfolioRisk.correlation.toFixed(2)} to below ${this.config.portfolioLimits.maxCorrelation}`\n      });\n    }\n    \n    // Stress test recommendations\n    if (stressTestResults?.some(result => !result.passed)) {\n      recommendations.push({\n        type: 'reduce_position',\n        priority: 'critical',\n        description: 'Stress tests indicate vulnerability to market shocks',\n        expectedImpact: 'Improve stress test resilience and reduce tail risk'\n      });\n    }\n    \n    return recommendations;\n  }\n\n  private createAlert(\n    type: RiskAlert['type'],\n    severity: RiskAlert['severity'],\n    message: string,\n    positions: string[]\n  ): void {\n    const alert: RiskAlert = {\n      id: `${type}_${Date.now()}`,\n      type,\n      severity,\n      message,\n      timestamp: new Date().toISOString(),\n      acknowledged: false,\n      positions\n    };\n    \n    this.alerts.set(alert.id, alert);\n    this.emit('risk-alert', alert);\n    \n    // Auto-remove old alerts (keep last 50)\n    const alertArray = Array.from(this.alerts.values());\n    if (alertArray.length > 50) {\n      const oldestAlerts = alertArray\n        .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())\n        .slice(0, alertArray.length - 50);\n      \n      for (const oldAlert of oldestAlerts) {\n        this.alerts.delete(oldAlert.id);\n      }\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  public destroy(): void {\n    this.killSwitch.destroy();\n    this.removeAllListeners();\n    this.positions.clear();\n    this.alerts.clear();\n  }\n}","// Main risk management exports\nexport {\n  GlobalKillSwitch,\n  type KillSwitchConfig,\n  type KillSwitchEvent,\n  type KillSwitchStatus\n} from './global-kill-switch';\n\nexport {\n  PositionSizingEngine,\n  type PositionSizingConfig,\n  type MarketData,\n  type TradeSignal,\n  type PositionResult,\n  type PortfolioRisk\n} from './position-sizing';\n\nexport {\n  RiskManager,\n  type RiskManagerConfig,\n  type StressTestScenario,\n  type Position,\n  type RiskReport,\n  type StressTestResult,\n  type RiskRecommendation,\n  type RiskAlert\n} from './risk-manager';\n\n// Import types for use in utility functions\nimport type { KillSwitchConfig } from './global-kill-switch';\nimport type { PositionSizingConfig } from './position-sizing';\nimport type { \n  StressTestScenario, \n  RiskManagerConfig,\n  RiskAlert,\n  Position \n} from './risk-manager';\n\n// Utility functions and helpers\nexport const createDefaultKillSwitchConfig = (): KillSwitchConfig => ({\n  enableAutoTrigger: true,\n  maxDailyLoss: 1000, // $1000 daily loss limit\n  maxDrawdown: 15, // 15% maximum drawdown\n  maxConsecutiveFailures: 5,\n  emergencyContacts: [],\n  gracefulShutdownTimeout: 30000, // 30 seconds\n  forceShutdownAfter: 120000 // 2 minutes\n});\n\nexport const createDefaultPositionSizingConfig = (): PositionSizingConfig => ({\n  baseRiskPerTrade: 2, // 2% of portfolio per trade\n  maxPositionSize: 10, // 10% max position size\n  minPositionSize: 100, // $100 minimum\n  volatilityLookback: 30, // 30 days\n  maxDailyRisk: 10, // 10% daily risk limit\n  correlationThreshold: 0.7, // 70% correlation threshold\n  riskScalingMethod: 'volatility',\n  enableDynamicSizing: true\n});\n\nexport const createDefaultStressTestScenarios = (): StressTestScenario[] => [\n  {\n    name: 'Market Crash',\n    description: '20% market decline with increased volatility',\n    marketShock: -20,\n    volatilityMultiplier: 2.0,\n    liquidityReduction: 50,\n    correlationIncrease: 0.3\n  },\n  {\n    name: 'Flash Crash',\n    description: '10% sudden decline with liquidity crisis',\n    marketShock: -10,\n    volatilityMultiplier: 3.0,\n    liquidityReduction: 80,\n    correlationIncrease: 0.5\n  },\n  {\n    name: 'Black Swan',\n    description: '30% market decline with extreme conditions',\n    marketShock: -30,\n    volatilityMultiplier: 4.0,\n    liquidityReduction: 90,\n    correlationIncrease: 0.8\n  },\n  {\n    name: 'Sector Rotation',\n    description: 'Moderate decline with correlation changes',\n    marketShock: -5,\n    volatilityMultiplier: 1.5,\n    liquidityReduction: 20,\n    correlationIncrease: 0.6\n  }\n];\n\nexport const createDefaultRiskManagerConfig = (): RiskManagerConfig => ({\n  killSwitch: createDefaultKillSwitchConfig(),\n  positionSizing: createDefaultPositionSizingConfig(),\n  portfolioLimits: {\n    maxPortfolioRisk: 20, // 20% maximum portfolio risk\n    maxSectorConcentration: 25, // 25% maximum in single sector\n    maxCorrelation: 0.8, // 80% maximum correlation\n    rebalanceThreshold: 15 // Rebalance at 15% deviation\n  },\n  stressTest: {\n    enabled: true,\n    scenarios: createDefaultStressTestScenarios(),\n    failureThreshold: 15 // 15% maximum acceptable loss in stress test\n  }\n});\n\n// Utility functions for risk calculations\nexport const calculateSharpeRatio = (returns: number[], riskFreeRate: number = 0.02): number => {\n  if (returns.length === 0) return 0;\n  \n  const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;\n  const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;\n  const volatility = Math.sqrt(variance);\n  \n  return volatility > 0 ? (avgReturn - riskFreeRate) / volatility : 0;\n};\n\nexport const calculateMaxDrawdown = (returns: number[]): number => {\n  if (returns.length === 0) return 0;\n  \n  let peak = 0;\n  let maxDrawdown = 0;\n  let cumulative = 0;\n  \n  for (const ret of returns) {\n    cumulative += ret;\n    peak = Math.max(peak, cumulative);\n    const drawdown = (peak - cumulative) / Math.max(peak, 1);\n    maxDrawdown = Math.max(maxDrawdown, drawdown);\n  }\n  \n  return maxDrawdown;\n};\n\nexport const calculateVaR = (returns: number[], confidenceLevel: number = 0.95): number => {\n  if (returns.length === 0) return 0;\n  \n  const sortedReturns = [...returns].sort((a, b) => a - b);\n  const index = Math.floor((1 - confidenceLevel) * sortedReturns.length);\n  \n  return sortedReturns[index] || 0;\n};\n\nexport const calculateCorrelation = (returns1: number[], returns2: number[]): number => {\n  if (returns1.length !== returns2.length || returns1.length === 0) return 0;\n  \n  const mean1 = returns1.reduce((sum, r) => sum + r, 0) / returns1.length;\n  const mean2 = returns2.reduce((sum, r) => sum + r, 0) / returns2.length;\n  \n  let numerator = 0;\n  let sumSq1 = 0;\n  let sumSq2 = 0;\n  \n  for (let i = 0; i < returns1.length; i++) {\n    const diff1 = returns1[i] - mean1;\n    const diff2 = returns2[i] - mean2;\n    \n    numerator += diff1 * diff2;\n    sumSq1 += diff1 * diff1;\n    sumSq2 += diff2 * diff2;\n  }\n  \n  const denominator = Math.sqrt(sumSq1 * sumSq2);\n  return denominator > 0 ? numerator / denominator : 0;\n};\n\n// Risk level classification\nexport const classifyRiskLevel = (\n  portfolioRisk: number,\n  maxRisk: number\n): 'low' | 'medium' | 'high' | 'critical' => {\n  const riskRatio = portfolioRisk / maxRisk;\n  \n  if (riskRatio <= 0.5) return 'low';\n  if (riskRatio <= 0.75) return 'medium';\n  if (riskRatio <= 1.0) return 'high';\n  return 'critical';\n};\n\n// Position sizing helpers\nexport const calculateKellyFraction = (\n  winProbability: number,\n  avgWin: number,\n  avgLoss: number\n): number => {\n  if (avgLoss === 0) return 0;\n  \n  const b = Math.abs(avgWin / avgLoss);\n  const kellyFraction = (b * winProbability - (1 - winProbability)) / b;\n  \n  // Apply safety margin (25% of optimal Kelly)\n  return Math.max(0, Math.min(0.25, kellyFraction * 0.25));\n};\n\n// Risk alert helpers\nexport const createRiskAlert = (\n  type: RiskAlert['type'],\n  severity: RiskAlert['severity'],\n  message: string,\n  positions: string[] = []\n): RiskAlert => ({\n  id: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n  type,\n  severity,\n  message,\n  timestamp: new Date().toISOString(),\n  acknowledged: false,\n  positions\n});\n\n// Portfolio analysis helpers\nexport const analyzePortfolioHealth = (\n  positions: Position[],\n  portfolioValue: number\n): {\n  diversificationScore: number;\n  concentrationRisk: number;\n  liquidityScore: number;\n  overallHealth: 'excellent' | 'good' | 'fair' | 'poor';\n} => {\n  if (positions.length === 0) {\n    return {\n      diversificationScore: 0,\n      concentrationRisk: 0,\n      liquidityScore: 0,\n      overallHealth: 'poor'\n    };\n  }\n  \n  // Calculate diversification score\n  const sectors = new Set(positions.map(p => p.sector || 'unknown'));\n  const diversificationScore = Math.min(100, (sectors.size / Math.max(positions.length / 3, 1)) * 100);\n  \n  // Calculate concentration risk\n  const positionSizes = positions.map(p => Math.abs(p.size));\n  const maxPosition = Math.max(...positionSizes);\n  const concentrationRisk = (maxPosition / portfolioValue) * 100;\n  \n  // Calculate liquidity score (simplified)\n  const avgPositionSize = positionSizes.reduce((sum, size) => sum + size, 0) / positions.length;\n  const liquidityScore = Math.max(0, 100 - (avgPositionSize / portfolioValue) * 50);\n  \n  // Determine overall health\n  const avgScore = (diversificationScore + (100 - concentrationRisk) + liquidityScore) / 3;\n  let overallHealth: 'excellent' | 'good' | 'fair' | 'poor';\n  \n  if (avgScore >= 80) overallHealth = 'excellent';\n  else if (avgScore >= 60) overallHealth = 'good';\n  else if (avgScore >= 40) overallHealth = 'fair';\n  else overallHealth = 'poor';\n  \n  return {\n    diversificationScore: Math.round(diversificationScore),\n    concentrationRisk: Math.round(concentrationRisk * 100) / 100,\n    liquidityScore: Math.round(liquidityScore),\n    overallHealth\n  };\n};\n\n// Version export\nexport const VERSION = '1.0.0';"]}