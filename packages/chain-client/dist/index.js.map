{"version":3,"sources":["../src/rpc-manager.ts","../src/connection-pool.ts","../src/chain-abstraction.ts","../src/dex-aggregator.ts"],"names":["EventEmitter","balance","axios"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport WebSocket from 'ws';\nimport winston from 'winston';\n\nexport interface RPCProvider {\n  id: string;\n  name: string;\n  tier: 'premium' | 'standard' | 'fallback';\n  url: string;\n  wsUrl?: string;\n  apiKey?: string;\n  rateLimit: number; // requests per second\n  maxConnections: number;\n  cost: number; // cost per 1000 requests\n  latency: number; // average latency in ms\n  successRate: number; // success rate percentage\n  isActive: boolean;\n  priority: number; // higher number = higher priority\n}\n\nexport interface RPCEndpoint {\n  provider: RPCProvider;\n  isHealthy: boolean;\n  latency: number;\n  successRate: number;\n  lastUsed: number;\n  requestCount: number;\n  errorCount: number;\n  consecutiveErrors: number;\n  isBlacklisted: boolean;\n  blacklistUntil?: number;\n}\n\nexport interface RPCRequest {\n  id: string;\n  method: string;\n  params: any[];\n  chain: string;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  timeout?: number;\n  retries?: number;\n  timestamp: number;\n  retryCount: number;\n  maxRetries: number;\n}\n\nexport interface RPCResponse {\n  id: string;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n  latency: number;\n  provider: string;\n}\n\nexport interface RPCMetrics {\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  averageLatency: number;\n  successRate: number;\n  costToday: number;\n  providerStats: Map<string, {\n    requests: number;\n    errors: number;\n    latency: number;\n    cost: number;\n  }>;\n}\n\nexport interface ProviderMetrics {\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  averageLatency: number;\n  costToday: number;\n  blacklistedUntil?: number;\n  lastHealthCheck: number;\n  isHealthy: boolean;\n}\n\nexport interface RPCManagerConfig {\n  providers: RPCProvider[];\n  maxRetries: number;\n  retryDelay: number;\n  healthCheckInterval: number;\n  blacklistDuration: number;\n  requestTimeout: number;\n  dailyBudget: number; // USD\n  costTrackingWindow: number; // hours\n}\n\nexport class RPCManager extends EventEmitter {\n  private logger: winston.Logger;\n  private providers: Map<string, RPCProvider> = new Map();\n  private endpoints: Map<string, RPCEndpoint> = new Map();\n  private requestQueue: Map<string, RPCRequest[]> = new Map(); // chain -> requests\n  private responseCache: Map<string, { response: any; expiry: number }> = new Map();\n  private axiosInstances: Map<string, AxiosInstance> = new Map();\n  private wsConnections: Map<string, WebSocket> = new Map();\n  private metrics: Map<string, ProviderMetrics> = new Map();\n  private isProcessingQueue = false;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private costTracker: Map<string, { timestamp: number; cost: number }[]> = new Map();\n\n  constructor(logger: winston.Logger, private config: RPCManagerConfig) {\n    super();\n    this.logger = logger;\n    this.setupDefaultProviders();\n    this.startHealthChecks();\n    this.startQueueProcessor();\n    this.startMetricsCollection();\n    this.startCostTracking();\n  }\n\n  private setupDefaultProviders(): void {\n    this.config.providers.forEach(provider => {\n      this.providers.set(provider.id, provider);\n      \n      // Initialize metrics\n      this.metrics.set(provider.id, {\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        averageLatency: provider.latency,\n        costToday: 0,\n        lastHealthCheck: Date.now(),\n        isHealthy: true\n      });\n\n      // Initialize HTTP client\n      const httpClient = axios.create({\n        baseURL: provider.url,\n        timeout: this.config.requestTimeout,\n        headers: provider.apiKey ? {\n          'Authorization': `Bearer ${provider.apiKey}`,\n          'Content-Type': 'application/json'\n        } : {\n          'Content-Type': 'application/json'\n        }\n      });\n\n      // Add response interceptor for metrics\n      httpClient.interceptors.response.use(\n        response => {\n          this.updateMetrics(provider.id, true, response.config.metadata?.startTime);\n          return response;\n        },\n        error => {\n          this.updateMetrics(provider.id, false, error.config?.metadata?.startTime);\n          return Promise.reject(error);\n        }\n      );\n\n      this.axiosInstances.set(provider.id, httpClient);\n      this.costTracker.set(provider.id, []);\n\n      // Initialize request queue for this chain\n      if (!this.requestQueue.has(provider.chain)) {\n        this.requestQueue.set(provider.chain, []);\n      }\n\n      // Initialize provider stats\n      this.metrics.get(provider.id)!.requests = 0;\n      this.metrics.get(provider.id)!.errors = 0;\n      this.metrics.get(provider.id)!.latency = 0;\n      this.metrics.get(provider.id)!.cost = 0;\n\n      this.logger.info('RPC provider added', {\n        id: provider.id,\n        name: provider.name,\n        chain: provider.chain,\n        tier: provider.tier,\n        priority: provider.priority\n      });\n    });\n\n    this.logger.info('Default RPC providers configured', {\n      totalProviders: this.providers.size,\n      chains: Array.from(new Set(Array.from(this.providers.values()).map(p => p.chain)))\n    });\n  }\n\n  private updateMetrics(providerId: string, success: boolean, startTime?: number): void {\n    const metrics = this.metrics.get(providerId);\n    if (!metrics) return;\n\n    metrics.totalRequests++;\n    \n    if (success) {\n      metrics.successfulRequests++;\n    } else {\n      metrics.failedRequests++;\n    }\n\n    if (startTime) {\n      const latency = Date.now() - startTime;\n      metrics.averageLatency = (metrics.averageLatency + latency) / 2;\n    }\n\n    metrics.isHealthy = (metrics.successfulRequests / metrics.totalRequests) > 0.8;\n    this.metrics.set(providerId, metrics);\n  }\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      await this.performHealthChecks();\n    }, this.config.healthCheckInterval);\n  }\n\n  private async performHealthChecks(): Promise<void> {\n    const healthCheckPromises = Array.from(this.providers.values()).map(async provider => {\n      try {\n        const client = this.axiosInstances.get(provider.id);\n        if (!client) return;\n\n        const startTime = Date.now();\n        await client.post('', {\n          jsonrpc: '2.0',\n          method: 'eth_blockNumber',\n          params: [],\n          id: 1\n        });\n\n        const latency = Date.now() - startTime;\n        const metrics = this.metrics.get(provider.id)!;\n        metrics.lastHealthCheck = Date.now();\n        metrics.isHealthy = true;\n        metrics.averageLatency = (metrics.averageLatency + latency) / 2;\n\n        // Update provider latency\n        provider.latency = metrics.averageLatency;\n\n        this.emit('healthCheck', { providerId: provider.id, healthy: true, latency });\n      } catch (error) {\n        const metrics = this.metrics.get(provider.id)!;\n        metrics.isHealthy = false;\n        metrics.lastHealthCheck = Date.now();\n\n        this.emit('healthCheck', { providerId: provider.id, healthy: false, error });\n        \n        // Temporarily blacklist provider\n        this.blacklistProvider(provider.id);\n      }\n    });\n\n    await Promise.allSettled(healthCheckPromises);\n  }\n\n  private blacklistProvider(providerId: string): void {\n    const metrics = this.metrics.get(providerId);\n    if (metrics) {\n      metrics.blacklistedUntil = Date.now() + this.config.blacklistDuration;\n      this.emit('providerBlacklisted', { providerId, until: metrics.blacklistedUntil });\n    }\n  }\n\n  private startCostTracking(): void {\n    setInterval(() => {\n      this.cleanupOldCostData();\n    }, 60 * 60 * 1000); // Every hour\n  }\n\n  private cleanupOldCostData(): void {\n    const cutoff = Date.now() - (this.config.costTrackingWindow * 60 * 60 * 1000);\n    \n    this.costTracker.forEach((costs, providerId) => {\n      const filteredCosts = costs.filter(entry => entry.timestamp > cutoff);\n      this.costTracker.set(providerId, filteredCosts);\n    });\n  }\n\n  private addCostEntry(providerId: string, cost: number): void {\n    const costs = this.costTracker.get(providerId) || [];\n    costs.push({ timestamp: Date.now(), cost });\n    this.costTracker.set(providerId, costs);\n\n    // Update daily cost in metrics\n    const metrics = this.metrics.get(providerId)!;\n    const todayStart = new Date().setHours(0, 0, 0, 0);\n    const todayCosts = costs.filter(entry => entry.timestamp >= todayStart);\n    metrics.costToday = todayCosts.reduce((total, entry) => total + entry.cost, 0);\n  }\n\n  private getAvailableProviders(): RPCProvider[] {\n    const now = Date.now();\n    \n    return Array.from(this.providers.values())\n      .filter(provider => {\n        const metrics = this.metrics.get(provider.id)!;\n        \n        // Filter out inactive providers\n        if (!provider.isActive) return false;\n        \n        // Filter out blacklisted providers\n        if (metrics.blacklistedUntil && metrics.blacklistedUntil > now) return false;\n        \n        // Filter out unhealthy providers\n        if (!metrics.isHealthy) return false;\n        \n        // Filter out providers over budget\n        if (metrics.costToday >= this.config.dailyBudget) return false;\n        \n        return true;\n      })\n      .sort((a, b) => {\n        // Sort by tier priority first, then by success rate and latency\n        const tierWeight = { premium: 3, standard: 2, fallback: 1 };\n        const aTierScore = tierWeight[a.tier] * 1000;\n        const bTierScore = tierWeight[b.tier] * 1000;\n        \n        const aMetrics = this.metrics.get(a.id)!;\n        const bMetrics = this.metrics.get(b.id)!;\n        \n        const aScore = aTierScore + a.priority + (aMetrics.successfulRequests / aMetrics.totalRequests) * 100 - a.latency;\n        const bScore = bTierScore + b.priority + (bMetrics.successfulRequests / bMetrics.totalRequests) * 100 - b.latency;\n        \n        return bScore - aScore;\n      });\n  }\n\n  public async makeRequest(method: string, params: any[] = [], options: {\n    timeout?: number;\n    retries?: number;\n    preferredProvider?: string;\n  } = {}): Promise<RPCResponse> {\n    const request: RPCRequest = {\n      id: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      method,\n      params,\n      chain: '',\n      priority: 'medium',\n      timestamp: Date.now(),\n      retryCount: 0,\n      maxRetries: options.retries || this.config.maxRetries\n    };\n\n    return this.executeRequest(request, options);\n  }\n\n  private async executeRequest(request: RPCRequest, options: any): Promise<RPCResponse> {\n    const availableProviders = this.getAvailableProviders();\n    \n    if (availableProviders.length === 0) {\n      throw new Error('No available RPC providers');\n    }\n\n    // Use preferred provider if specified and available\n    let targetProvider = availableProviders[0];\n    if (options.preferredProvider) {\n      const preferred = availableProviders.find(p => p.id === options.preferredProvider);\n      if (preferred) targetProvider = preferred;\n    }\n\n    const startTime = Date.now();\n\n    try {\n      const client = this.axiosInstances.get(targetProvider.id)!;\n      \n      // Add metadata for metrics\n      const config: AxiosRequestConfig = {\n        metadata: { startTime }\n      };\n\n      const response = await client.post('', {\n        jsonrpc: '2.0',\n        method: request.method,\n        params: request.params,\n        id: request.id\n      }, config);\n\n      const latency = Date.now() - startTime;\n\n      // Track cost\n      const requestCost = (targetProvider.cost / 1000);\n      this.addCostEntry(targetProvider.id, requestCost);\n\n      const rpcResponse: RPCResponse = {\n        id: request.id,\n        result: response.data.result,\n        error: response.data.error,\n        latency,\n        provider: targetProvider.id\n      };\n\n      this.emit('requestCompleted', { request, response: rpcResponse, provider: targetProvider.id });\n\n      if (rpcResponse.error) {\n        throw new Error(`RPC Error: ${rpcResponse.error.message}`);\n      }\n\n      return rpcResponse;\n\n    } catch (error) {\n      this.emit('requestFailed', { request, error, provider: targetProvider.id });\n\n      // Retry with different provider if possible\n      if (request.retryCount < request.maxRetries) {\n        request.retryCount++;\n        \n        // Wait before retry\n        await new Promise(resolve => setTimeout(resolve, this.config.retryDelay * Math.pow(2, request.retryCount)));\n        \n        // Temporarily blacklist failed provider for this request\n        const filteredProviders = availableProviders.filter(p => p.id !== targetProvider.id);\n        if (filteredProviders.length > 0) {\n          return this.executeRequest(request, { ...options, preferredProvider: undefined });\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  public async batchRequest(requests: Array<{ method: string; params: any[] }>): Promise<RPCResponse[]> {\n    const batchPromises = requests.map(req => this.makeRequest(req.method, req.params));\n    return Promise.all(batchPromises);\n  }\n\n  public getProviderMetrics(providerId?: string): ProviderMetrics | Map<string, ProviderMetrics> {\n    if (providerId) {\n      const metrics = this.metrics.get(providerId);\n      if (!metrics) throw new Error(`Provider ${providerId} not found`);\n      return metrics;\n    }\n    return new Map(this.metrics);\n  }\n\n  public getProviderStatus(): Array<{ provider: RPCProvider; metrics: ProviderMetrics }> {\n    return Array.from(this.providers.values()).map(provider => ({\n      provider,\n      metrics: this.metrics.get(provider.id)!\n    }));\n  }\n\n  public async addProvider(provider: RPCProvider): Promise<void> {\n    this.providers.set(provider.id, provider);\n    \n    // Initialize metrics\n    this.metrics.set(provider.id, {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      averageLatency: provider.latency,\n      costToday: 0,\n      lastHealthCheck: Date.now(),\n      isHealthy: true\n    });\n\n    // Initialize HTTP client\n    const httpClient = axios.create({\n      baseURL: provider.url,\n      timeout: this.config.requestTimeout,\n      headers: provider.apiKey ? {\n        'Authorization': `Bearer ${provider.apiKey}`,\n        'Content-Type': 'application/json'\n      } : {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    this.axiosInstances.set(provider.id, httpClient);\n    this.costTracker.set(provider.id, []);\n\n    this.emit('providerAdded', provider);\n  }\n\n  public removeProvider(providerId: string): void {\n    this.providers.delete(providerId);\n    this.metrics.delete(providerId);\n    this.axiosInstances.delete(providerId);\n    this.costTracker.delete(providerId);\n\n    // Close WebSocket if exists\n    const ws = this.wsConnections.get(providerId);\n    if (ws) {\n      ws.close();\n      this.wsConnections.delete(providerId);\n    }\n\n    this.emit('providerRemoved', providerId);\n  }\n\n  public setProviderActive(providerId: string, active: boolean): void {\n    const provider = this.providers.get(providerId);\n    if (provider) {\n      provider.isActive = active;\n      this.emit('providerStatusChanged', { providerId, active });\n    }\n  }\n\n  public getTotalCosts(): { daily: number; window: number; breakdown: Record<string, number> } {\n    const now = Date.now();\n    const todayStart = new Date().setHours(0, 0, 0, 0);\n    const windowStart = now - (this.config.costTrackingWindow * 60 * 60 * 1000);\n\n    let dailyTotal = 0;\n    let windowTotal = 0;\n    const breakdown: Record<string, number> = {};\n\n    this.costTracker.forEach((costs, providerId) => {\n      const dailyCosts = costs.filter(entry => entry.timestamp >= todayStart);\n      const windowCosts = costs.filter(entry => entry.timestamp >= windowStart);\n\n      const dailySum = dailyCosts.reduce((sum, entry) => sum + entry.cost, 0);\n      const windowSum = windowCosts.reduce((sum, entry) => sum + entry.cost, 0);\n\n      dailyTotal += dailySum;\n      windowTotal += windowSum;\n      breakdown[providerId] = dailySum;\n    });\n\n    return { daily: dailyTotal, window: windowTotal, breakdown };\n  }\n\n  public optimizeForCost(): void {\n    // Reorder providers to prioritize cost-effective ones\n    const providers = Array.from(this.providers.values());\n    providers.forEach(provider => {\n      const metrics = this.metrics.get(provider.id)!;\n      const costEfficiency = metrics.successfulRequests / (metrics.costToday + 1);\n      provider.priority = Math.floor(costEfficiency * 100);\n    });\n\n    this.emit('optimizedForCost');\n  }\n\n  public optimizeForSpeed(): void {\n    // Reorder providers to prioritize low-latency ones\n    const providers = Array.from(this.providers.values());\n    providers.forEach(provider => {\n      const metrics = this.metrics.get(provider.id)!;\n      provider.priority = Math.floor(1000 / (metrics.averageLatency + 1));\n    });\n\n    this.emit('optimizedForSpeed');\n  }\n\n  public destroy(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n\n    // Close all WebSocket connections\n    this.wsConnections.forEach(ws => ws.close());\n    this.wsConnections.clear();\n\n    // Clear all data\n    this.providers.clear();\n    this.metrics.clear();\n    this.axiosInstances.clear();\n    this.costTracker.clear();\n    this.requestQueue.clear();\n\n    this.removeAllListeners();\n  }\n\n  // WebSocket Connection Management\n  async createWebSocketConnection(chain: string): Promise<WebSocket | null> {\n    const endpoint = this.selectBestProvider(chain, 'high');\n    if (!endpoint || !endpoint.provider.wsUrl) {\n      this.logger.warn('No WebSocket endpoint available for chain', { chain });\n      return null;\n    }\n\n    const wsKey = `${chain}-${endpoint.provider.id}`;\n    \n    // Close existing connection if any\n    if (this.wsConnections.has(wsKey)) {\n      this.wsConnections.get(wsKey)?.close();\n    }\n\n    try {\n      const ws = new WebSocket(endpoint.provider.wsUrl);\n      \n      ws.on('open', () => {\n        this.logger.info('WebSocket connected', {\n          chain,\n          provider: endpoint.provider.id\n        });\n        this.emit('wsConnected', { chain, provider: endpoint.provider.id });\n      });\n\n      ws.on('message', (data: any) => {\n        try {\n          const message = JSON.parse(data.toString());\n          this.emit('wsMessage', { chain, provider: endpoint.provider.id, message });\n        } catch (error) {\n          this.logger.error('Error parsing WebSocket message:', error);\n        }\n      });\n\n      ws.on('error', (error: any) => {\n        this.logger.error('WebSocket error', {\n          chain,\n          provider: endpoint.provider.id,\n          error: error.message\n        });\n        this.emit('wsError', { chain, provider: endpoint.provider.id, error });\n      });\n\n      ws.on('close', () => {\n        this.logger.warn('WebSocket disconnected', {\n          chain,\n          provider: endpoint.provider.id\n        });\n        this.wsConnections.delete(wsKey);\n        this.emit('wsDisconnected', { chain, provider: endpoint.provider.id });\n        \n        // Auto-reconnect after 5 seconds\n        setTimeout(() => {\n          this.createWebSocketConnection(chain);\n        }, 5000);\n      });\n\n      this.wsConnections.set(wsKey, ws);\n      return ws;\n    } catch (error: any) {\n      this.logger.error('Failed to create WebSocket connection', {\n        chain,\n        provider: endpoint.provider.id,\n        error: error.message\n      });\n      return null;\n    }\n  }\n\n  // Queue-based request processing for rate limiting\n  async queueRequest(request: RPCRequest): Promise<RPCResponse> {\n    return new Promise((resolve, reject) => {\n      const queue = this.requestQueue.get(request.chain) || [];\n      queue.push(request);\n      this.requestQueue.set(request.chain, queue);\n\n      // Store resolve/reject functions\n      (request as any).resolve = resolve;\n      (request as any).reject = reject;\n    });\n  }\n\n  private async startQueueProcessor(): Promise<void> {\n    if (this.isProcessingQueue) return;\n    this.isProcessingQueue = true;\n\n    const processQueue = async () => {\n      for (const [chain, queue] of this.requestQueue.entries()) {\n        if (queue.length === 0) continue;\n\n        // Process requests based on rate limits\n        const endpoint = this.selectBestProvider(chain);\n        if (!endpoint) continue;\n\n        const rateLimit = endpoint.provider.rateLimit;\n        const requestsToProcess = Math.min(queue.length, rateLimit);\n\n        for (let i = 0; i < requestsToProcess; i++) {\n          const request = queue.shift();\n          if (!request) continue;\n\n          try {\n            const response = await this.makeRequest(request.method, request.params, {\n              timeout: request.timeout,\n              retries: request.retries,\n              preferredProvider: request.preferredProvider\n            });\n            (request as any).resolve(response);\n          } catch (error) {\n            (request as any).reject(error);\n          }\n        }\n      }\n    };\n\n    // Process queue every second\n    setInterval(processQueue, 1000);\n  }\n\n  // Health Check System\n  private selectBestProvider(chain: string, priority: string = 'medium'): RPCEndpoint | null {\n    const chainProviders = Array.from(this.endpoints.values())\n      .filter(endpoint => \n        endpoint.provider.chain === chain && \n        endpoint.isHealthy && \n        !endpoint.isBlacklisted\n      );\n\n    if (chainProviders.length === 0) {\n      this.logger.warn('No healthy providers available for chain', { chain });\n      return null;\n    }\n\n    // Sort by multiple criteria\n    chainProviders.sort((a, b) => {\n      // 1. Priority tier (premium > standard > fallback)\n      const tierWeight = { premium: 3, standard: 2, fallback: 1 };\n      const tierDiff = tierWeight[b.provider.tier] - tierWeight[a.provider.tier];\n      if (tierDiff !== 0) return tierDiff;\n\n      // 2. Success rate\n      const successRateDiff = b.successRate - a.successRate;\n      if (Math.abs(successRateDiff) > 5) return successRateDiff;\n\n      // 3. Latency (lower is better)\n      const latencyDiff = a.latency - b.latency;\n      if (Math.abs(latencyDiff) > 100) return latencyDiff;\n\n      // 4. Provider priority\n      const priorityDiff = b.provider.priority - a.provider.priority;\n      if (priorityDiff !== 0) return priorityDiff;\n\n      // 5. Load balancing - prefer less recently used\n      return a.lastUsed - b.lastUsed;\n    });\n\n    // For critical requests, always use the best provider\n    if (priority === 'critical') {\n      return chainProviders[0];\n    }\n\n    // For other requests, use weighted random selection from top 3\n    const topProviders = chainProviders.slice(0, Math.min(3, chainProviders.length));\n    const weights = topProviders.map((_, index) => Math.pow(2, topProviders.length - index - 1));\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\n    \n    let random = Math.random() * totalWeight;\n    for (let i = 0; i < topProviders.length; i++) {\n      random -= weights[i];\n      if (random <= 0) {\n        return topProviders[i];\n      }\n    }\n\n    return topProviders[0];\n  }\n\n  // Metrics and monitoring\n  private updateEndpointMetrics(endpoint: RPCEndpoint, latency: number, success: boolean): void {\n    endpoint.requestCount++;\n    \n    if (success) {\n      endpoint.latency = (endpoint.latency * 0.9) + (latency * 0.1);\n      endpoint.consecutiveErrors = 0;\n    } else {\n      endpoint.errorCount++;\n      endpoint.consecutiveErrors++;\n    }\n\n    endpoint.successRate = ((endpoint.requestCount - endpoint.errorCount) / endpoint.requestCount) * 100;\n  }\n\n  private updateGlobalMetrics(providerId: string, latency: number, success: boolean): void {\n    const metrics = this.metrics.get(providerId);\n    if (!metrics) return;\n\n    metrics.totalRequests++;\n    \n    if (success) {\n      metrics.successfulRequests++;\n    } else {\n      metrics.failedRequests++;\n    }\n\n    metrics.successRate = (metrics.successfulRequests / metrics.totalRequests) * 100;\n    metrics.averageLatency = (metrics.averageLatency * 0.95) + (latency * 0.05);\n\n    // Update provider-specific stats\n    const provider = this.providers.get(providerId);\n    if (provider) {\n      metrics.requests++;\n      metrics.latency = (metrics.latency * 0.9) + (latency * 0.1);\n      \n      if (!success) {\n        metrics.errors++;\n      }\n\n      // Update cost\n      const cost = (provider.cost / 1000) * (metrics.requests / 1000);\n      metrics.cost += cost;\n      metrics.costToday += cost;\n    }\n  }\n\n  private startMetricsCollection(): void {\n    // Reset daily cost at midnight\n    const resetDailyCost = () => {\n      const now = new Date();\n      const tomorrow = new Date(now);\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      tomorrow.setHours(0, 0, 0, 0);\n      \n      const msUntilMidnight = tomorrow.getTime() - now.getTime();\n      \n      setTimeout(() => {\n        this.metrics.forEach(metrics => {\n          metrics.costToday = 0;\n        });\n        this.logger.info('Daily RPC cost metrics reset');\n        \n        // Set up recurring daily reset\n        setInterval(() => {\n          this.metrics.forEach(metrics => {\n            metrics.costToday = 0;\n          });\n          this.logger.info('Daily RPC cost metrics reset');\n        }, 24 * 60 * 60 * 1000);\n      }, msUntilMidnight);\n    };\n\n    resetDailyCost();\n\n    // Log metrics every 5 minutes\n    setInterval(() => {\n      this.logger.info('RPC Metrics Summary', {\n        totalRequests: this.metrics.totalRequests,\n        successRate: this.metrics.successRate.toFixed(2) + '%',\n        averageLatency: this.metrics.averageLatency.toFixed(0) + 'ms',\n        costToday: '$' + this.metrics.costToday.toFixed(6),\n        healthyProviders: Array.from(this.endpoints.values()).filter(e => e.isHealthy).length,\n        blacklistedProviders: Array.from(this.endpoints.values()).filter(e => e.isBlacklisted).length\n      });\n    }, 5 * 60 * 1000);\n  }\n\n  // Utility methods\n  private isCacheable(method: string): boolean {\n    const cacheableMethods = [\n      'eth_blockNumber',\n      'eth_gasPrice',\n      'eth_getBalance',\n      'eth_getTransactionCount',\n      'eth_call',\n      'getHealth'\n    ];\n    return cacheableMethods.includes(method);\n  }\n\n  private getCacheKey(request: RPCRequest): string {\n    return `${request.chain}:${request.method}:${JSON.stringify(request.params)}`;\n  }\n\n  private cacheResponse(request: RPCRequest, response: any): void {\n    const cacheKey = this.getCacheKey(request);\n    const cacheDuration = this.getCacheDuration(request.method);\n    \n    this.responseCache.set(cacheKey, {\n      response,\n      expiry: Date.now() + cacheDuration\n    });\n\n    // Clean up expired cache entries\n    if (this.responseCache.size > 10000) {\n      this.cleanupCache();\n    }\n  }\n\n  private getCacheDuration(method: string): number {\n    const durations: Record<string, number> = {\n      'eth_blockNumber': 1000,      // 1 second\n      'eth_gasPrice': 5000,         // 5 seconds  \n      'eth_getBalance': 10000,      // 10 seconds\n      'eth_getTransactionCount': 10000, // 10 seconds\n      'eth_call': 30000,            // 30 seconds\n      'getHealth': 60000            // 1 minute\n    };\n    \n    return durations[method] || 30000;\n  }\n\n  private cleanupCache(): void {\n    const now = Date.now();\n    for (const [key, value] of this.responseCache.entries()) {\n      if (value.expiry < now) {\n        this.responseCache.delete(key);\n      }\n    }\n  }\n\n  private isRetryableError(error: any): boolean {\n    const retryableErrors = [\n      'ECONNRESET',\n      'ENOTFOUND',\n      'ECONNREFUSED',\n      'ETIMEDOUT',\n      'Network Error',\n      'timeout'\n    ];\n    \n    return retryableErrors.some(retryableError => \n      error.message?.includes(retryableError) || \n      error.code?.includes(retryableError)\n    );\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Public API methods\n  getMetrics(): RPCMetrics {\n    return {\n      totalRequests: this.metrics.totalRequests,\n      successfulRequests: this.metrics.successfulRequests,\n      failedRequests: this.metrics.failedRequests,\n      averageLatency: this.metrics.averageLatency,\n      successRate: this.metrics.successRate,\n      costToday: this.metrics.costToday,\n      providerStats: new Map(this.metrics.map(metrics => [\n        metrics.id,\n        {\n          requests: metrics.requests,\n          errors: metrics.errors,\n          latency: metrics.latency,\n          cost: metrics.cost\n        }\n      ]))\n    };\n  }\n\n  async optimizeForLatency(chain: string): Promise<void> {\n    // Run latency tests on all providers for the chain\n    const endpoints = Array.from(this.endpoints.values())\n      .filter(e => e.provider.chain === chain && e.isHealthy);\n\n    const latencyTests = endpoints.map(async (endpoint) => {\n      const testRequest: RPCRequest = {\n        id: `latency-test-${Date.now()}`,\n        method: chain === 'solana' ? 'getHealth' : 'eth_blockNumber',\n        params: [],\n        chain,\n        priority: 'low',\n        timestamp: Date.now(),\n        retryCount: 0,\n        maxRetries: 0\n      };\n\n      const startTime = Date.now();\n      try {\n        await this.executeRequest(testRequest, {});\n        return { endpoint, latency: Date.now() - startTime };\n      } catch (error) {\n        return { endpoint, latency: 999999 }; // Max latency for failed requests\n      }\n    });\n\n    const results = await Promise.all(latencyTests);\n    \n    // Update priorities based on latency results\n    results.sort((a, b) => a.latency - b.latency);\n    results.forEach((result, index) => {\n      const priorityBoost = Math.max(0, 20 - (index * 2));\n      result.endpoint.provider.priority += priorityBoost;\n    });\n\n    this.logger.info('Latency optimization completed', {\n      chain,\n      results: results.map(r => ({\n        provider: r.endpoint.provider.id,\n        latency: r.latency,\n        newPriority: r.endpoint.provider.priority\n      }))\n    });\n  }\n\n  async getOptimalProvider(chain: string, method: string): Promise<string | null> {\n    const endpoint = this.selectBestProvider(chain, 'high');\n    return endpoint?.provider.id || null;\n  }\n\n  getConnectionStatus(): { [chain: string]: boolean } {\n    const status: { [chain: string]: boolean } = {};\n    \n    for (const provider of this.providers.values()) {\n      if (!status[provider.chain]) {\n        status[provider.chain] = false;\n      }\n      \n      const endpoint = this.endpoints.get(provider.id);\n      if (endpoint?.isHealthy && !endpoint.isBlacklisted) {\n        status[provider.chain] = true;\n      }\n    }\n    \n    return status;\n  }\n\n  async close(): Promise<void> {\n    // Close all WebSocket connections\n    for (const ws of this.wsConnections.values()) {\n      ws.close();\n    }\n    this.wsConnections.clear();\n\n    // Clear intervals and timeouts\n    this.isProcessingQueue = false;\n\n    this.logger.info('RPC Manager closed');\n  }\n}","import { EventEmitter } from 'events';\nimport winston from 'winston';\nimport { RPCManager, RPCRequest, RPCResponse } from './rpc-manager';\n\nexport interface PoolConnection {\n  id: string;\n  providerId: string;\n  isActive: boolean;\n  isBusy: boolean;\n  lastUsed: number;\n  createdAt: number;\n  requestCount: number;\n  errorCount: number;\n  averageResponseTime: number;\n  consecutiveErrors: number;\n  maxConsecutiveErrors: number;\n  healthScore: number; // 0-100\n}\n\nexport interface LoadBalancer {\n  strategy: 'round-robin' | 'least-connections' | 'weighted' | 'latency-based';\n  weights?: Map<string, number>;\n  currentIndex?: number;\n}\n\nexport interface ConnectionPoolConfig {\n  maxConnections: number;\n  minConnections: number;\n  maxConnectionAge: number; // milliseconds\n  idleTimeout: number; // milliseconds\n  healthCheckInterval: number; // milliseconds\n  maxConsecutiveErrors: number;\n  connectionTimeout: number; // milliseconds\n  retryDelay: number; // milliseconds\n  scaleUpThreshold: number; // percentage of busy connections\n  scaleDownThreshold: number; // percentage of idle connections\n  loadBalancer: LoadBalancer;\n}\n\nexport interface PoolMetrics {\n  totalConnections: number;\n  activeConnections: number;\n  busyConnections: number;\n  idleConnections: number;\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  averageResponseTime: number;\n  poolUtilization: number; // percentage\n  connectionsCreated: number;\n  connectionsDestroyed: number;\n  healthChecksPassed: number;\n  healthChecksFailed: number;\n}\n\nexport class ConnectionPool extends EventEmitter {\n  private logger: winston.Logger;\n  private rpcManager: RPCManager;\n  private config: ConnectionPoolConfig;\n  private connections: Map<string, PoolConnection> = new Map();\n  private providerPools: Map<string, Set<string>> = new Map();\n  private requestQueue: Array<{\n    resolve: (connection: PoolConnection) => void;\n    reject: (error: Error) => void;\n    timeout: NodeJS.Timeout;\n    priority: number;\n    timestamp: number;\n  }> = [];\n  \n  private metrics: PoolMetrics = {\n    totalConnections: 0,\n    activeConnections: 0,\n    busyConnections: 0,\n    idleConnections: 0,\n    totalRequests: 0,\n    successfulRequests: 0,\n    failedRequests: 0,\n    averageResponseTime: 0,\n    poolUtilization: 0,\n    connectionsCreated: 0,\n    connectionsDestroyed: 0,\n    healthChecksPassed: 0,\n    healthChecksFailed: 0\n  };\n\n  private healthCheckInterval?: NodeJS.Timeout;\n  private scaleTimer?: NodeJS.Timeout;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  constructor(\n    rpcManager: RPCManager,\n    config: ConnectionPoolConfig,\n    logger: winston.Logger\n  ) {\n    super();\n    this.rpcManager = rpcManager;\n    this.config = config;\n    this.logger = logger;\n    \n    this.startHealthChecks();\n    this.startAutoScaling();\n    this.startCleanupTimer();\n  }\n\n  // Connection Management\n  public async getConnection(providerId: string, priority: number = 1): Promise<PoolConnection> {\n    const startTime = Date.now();\n    \n    try {\n      // Try to get an existing idle connection\n      const existingConnection = this.getIdleConnection(providerId);\n      if (existingConnection) {\n        this.markConnectionBusy(existingConnection);\n        this.updateMetrics('connectionAcquired', Date.now() - startTime);\n        return existingConnection;\n      }\n\n      // Check if we can create a new connection\n      if (this.canCreateNewConnection(providerId)) {\n        const newConnection = await this.createConnection(providerId);\n        this.markConnectionBusy(newConnection);\n        this.updateMetrics('connectionCreated', Date.now() - startTime);\n        return newConnection;\n      }\n\n      // Queue the request if pool is full\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          const index = this.requestQueue.findIndex(item => item.resolve === resolve);\n          if (index !== -1) {\n            this.requestQueue.splice(index, 1);\n          }\n          reject(new Error(`Connection request timeout after ${this.config.connectionTimeout}ms`));\n        }, this.config.connectionTimeout);\n\n        this.requestQueue.push({\n          resolve,\n          reject,\n          timeout,\n          priority,\n          timestamp: Date.now()\n        });\n\n        // Sort queue by priority (higher priority first) and timestamp\n        this.requestQueue.sort((a, b) => {\n          if (a.priority !== b.priority) {\n            return b.priority - a.priority;\n          }\n          return a.timestamp - b.timestamp;\n        });\n      });\n\n    } catch (error) {\n      this.updateMetrics('connectionError', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  public releaseConnection(connectionId: string): void {\n    const connection = this.connections.get(connectionId);\n    if (!connection) {\n      throw new Error(`Connection ${connectionId} not found`);\n    }\n\n    this.markConnectionIdle(connection);\n    this.processQueue();\n    this.updateMetrics('connectionReleased');\n  }\n\n  public async destroyConnection(connectionId: string): Promise<void> {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return;\n\n    // Remove from pools\n    const providerPool = this.providerPools.get(connection.providerId);\n    if (providerPool) {\n      providerPool.delete(connectionId);\n    }\n\n    // Remove from connections\n    this.connections.delete(connectionId);\n\n    // Update metrics\n    this.metrics.connectionsDestroyed++;\n    this.updateConnectionCounts();\n\n    this.emit('connectionDestroyed', connection);\n\n    // Process any queued requests\n    this.processQueue();\n  }\n\n  // Load Balancing\n  public selectConnectionByStrategy(providerId: string): PoolConnection | null {\n    const providerPool = this.providerPools.get(providerId);\n    if (!providerPool || providerPool.size === 0) return null;\n\n    const availableConnections = Array.from(providerPool)\n      .map(id => this.connections.get(id)!)\n      .filter(conn => conn.isActive && !conn.isBusy && conn.consecutiveErrors < conn.maxConsecutiveErrors);\n\n    if (availableConnections.length === 0) return null;\n\n    switch (this.config.loadBalancer.strategy) {\n      case 'round-robin':\n        return this.roundRobinSelection(availableConnections);\n      \n      case 'least-connections':\n        return this.leastConnectionsSelection(availableConnections);\n      \n      case 'weighted':\n        return this.weightedSelection(availableConnections);\n      \n      case 'latency-based':\n        return this.latencyBasedSelection(availableConnections);\n      \n      default:\n        return availableConnections[0];\n    }\n  }\n\n  private roundRobinSelection(connections: PoolConnection[]): PoolConnection {\n    const currentIndex = this.config.loadBalancer.currentIndex || 0;\n    const selectedConnection = connections[currentIndex % connections.length];\n    this.config.loadBalancer.currentIndex = (currentIndex + 1) % connections.length;\n    return selectedConnection;\n  }\n\n  private leastConnectionsSelection(connections: PoolConnection[]): PoolConnection {\n    return connections.reduce((least, current) => \n      current.requestCount < least.requestCount ? current : least\n    );\n  }\n\n  private weightedSelection(connections: PoolConnection[]): PoolConnection {\n    const weights = this.config.loadBalancer.weights || new Map();\n    const weightedConnections = connections.map(conn => ({\n      connection: conn,\n      weight: weights.get(conn.providerId) || 1\n    }));\n\n    const totalWeight = weightedConnections.reduce((sum, item) => sum + item.weight, 0);\n    let random = Math.random() * totalWeight;\n\n    for (const item of weightedConnections) {\n      random -= item.weight;\n      if (random <= 0) {\n        return item.connection;\n      }\n    }\n\n    return connections[0];\n  }\n\n  private latencyBasedSelection(connections: PoolConnection[]): PoolConnection {\n    // Sort by average response time (lower is better) and health score (higher is better)\n    return connections.sort((a, b) => {\n      const latencyDiff = a.averageResponseTime - b.averageResponseTime;\n      if (Math.abs(latencyDiff) > 10) { // 10ms threshold\n        return latencyDiff;\n      }\n      return b.healthScore - a.healthScore;\n    })[0];\n  }\n\n  // Connection Creation and Management\n  private async createConnection(providerId: string): Promise<PoolConnection> {\n    const connectionId = `conn_${providerId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const connection: PoolConnection = {\n      id: connectionId,\n      providerId,\n      isActive: true,\n      isBusy: false,\n      lastUsed: Date.now(),\n      createdAt: Date.now(),\n      requestCount: 0,\n      errorCount: 0,\n      averageResponseTime: 0,\n      consecutiveErrors: 0,\n      maxConsecutiveErrors: this.config.maxConsecutiveErrors,\n      healthScore: 100\n    };\n\n    this.connections.set(connectionId, connection);\n\n    // Add to provider pool\n    if (!this.providerPools.has(providerId)) {\n      this.providerPools.set(providerId, new Set());\n    }\n    this.providerPools.get(providerId)!.add(connectionId);\n\n    // Update metrics\n    this.metrics.connectionsCreated++;\n    this.updateConnectionCounts();\n\n    this.emit('connectionCreated', connection);\n\n    return connection;\n  }\n\n  private getIdleConnection(providerId: string): PoolConnection | null {\n    return this.selectConnectionByStrategy(providerId);\n  }\n\n  private canCreateNewConnection(providerId: string): boolean {\n    const currentConnections = this.connections.size;\n    const providerConnections = this.providerPools.get(providerId)?.size || 0;\n    \n    return currentConnections < this.config.maxConnections && \n           providerConnections < this.config.maxConnections;\n  }\n\n  private markConnectionBusy(connection: PoolConnection): void {\n    connection.isBusy = true;\n    connection.lastUsed = Date.now();\n    connection.requestCount++;\n    this.updateConnectionCounts();\n  }\n\n  private markConnectionIdle(connection: PoolConnection): void {\n    connection.isBusy = false;\n    this.updateConnectionCounts();\n  }\n\n  private async processQueue(): Promise<void> {\n    while (this.requestQueue.length > 0) {\n      const request = this.requestQueue[0];\n      \n      // Find any available connection (round-robin across providers)\n      let availableConnection: PoolConnection | null = null;\n      \n      for (const [providerId] of this.providerPools) {\n        availableConnection = this.getIdleConnection(providerId);\n        if (availableConnection) break;\n      }\n\n      if (!availableConnection) {\n        // Try to create a new connection for any provider\n        let newConnection: PoolConnection | null = null;\n        \n        for (const [providerId] of this.providerPools) {\n          if (this.canCreateNewConnection(providerId)) {\n            try {\n              newConnection = await this.createConnection(providerId);\n              break;\n            } catch (error) {\n              continue;\n            }\n          }\n        }\n\n        if (!newConnection) {\n          break; // No connections available, stop processing queue\n        }\n\n        availableConnection = newConnection;\n      }\n\n      // Remove request from queue and fulfill it\n      this.requestQueue.shift();\n      clearTimeout(request.timeout);\n      \n      this.markConnectionBusy(availableConnection);\n      request.resolve(availableConnection);\n    }\n  }\n\n  // Health Monitoring\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      await this.performHealthChecks();\n    }, this.config.healthCheckInterval);\n  }\n\n  private async performHealthChecks(): Promise<void> {\n    const healthCheckPromises = Array.from(this.connections.values()).map(async connection => {\n      try {\n        const startTime = Date.now();\n        \n        // Simulate health check (in real implementation, this would be an actual request)\n        await this.simulateHealthCheck(connection);\n        \n        const responseTime = Date.now() - startTime;\n        \n        // Update connection health metrics\n        connection.averageResponseTime = (connection.averageResponseTime * 0.8) + (responseTime * 0.2);\n        connection.consecutiveErrors = 0;\n        connection.healthScore = Math.min(100, connection.healthScore + 10);\n        \n        this.metrics.healthChecksPassed++;\n        \n      } catch (error) {\n        connection.consecutiveErrors++;\n        connection.errorCount++;\n        connection.healthScore = Math.max(0, connection.healthScore - 20);\n        \n        this.metrics.healthChecksFailed++;\n        \n        // Deactivate connection if too many consecutive errors\n        if (connection.consecutiveErrors >= connection.maxConsecutiveErrors) {\n          connection.isActive = false;\n          this.emit('connectionUnhealthy', connection);\n        }\n      }\n    });\n\n    await Promise.allSettled(healthCheckPromises);\n    this.updateConnectionCounts();\n  }\n\n  private async simulateHealthCheck(connection: PoolConnection): Promise<void> {\n    // Simulate health check delay and potential failure\n    await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        // 95% success rate for healthy connections\n        if (Math.random() < 0.95 || connection.healthScore > 80) {\n          resolve(undefined);\n        } else {\n          reject(new Error('Health check failed'));\n        }\n      }, Math.random() * 100 + 10); // 10-110ms delay\n    });\n  }\n\n  // Auto-scaling\n  private startAutoScaling(): void {\n    this.scaleTimer = setInterval(() => {\n      this.evaluateScaling();\n    }, 10000); // Check every 10 seconds\n  }\n\n  private evaluateScaling(): void {\n    const utilization = this.getUtilization();\n    \n    // Scale up if utilization is high\n    if (utilization > this.config.scaleUpThreshold) {\n      this.scaleUp();\n    }\n    \n    // Scale down if utilization is low\n    else if (utilization < this.config.scaleDownThreshold) {\n      this.scaleDown();\n    }\n  }\n\n  private getUtilization(): number {\n    const totalConnections = this.connections.size;\n    if (totalConnections === 0) return 0;\n    \n    const busyConnections = Array.from(this.connections.values())\n      .filter(conn => conn.isBusy).length;\n    \n    return (busyConnections / totalConnections) * 100;\n  }\n\n  private async scaleUp(): Promise<void> {\n    // Find the provider with the highest load\n    let targetProviderId: string | null = null;\n    let maxLoad = 0;\n\n    for (const [providerId, connectionIds] of this.providerPools) {\n      const providerConnections = Array.from(connectionIds)\n        .map(id => this.connections.get(id)!)\n        .filter(conn => conn.isActive);\n      \n      const busyCount = providerConnections.filter(conn => conn.isBusy).length;\n      const load = busyCount / Math.max(providerConnections.length, 1);\n      \n      if (load > maxLoad && this.canCreateNewConnection(providerId)) {\n        maxLoad = load;\n        targetProviderId = providerId;\n      }\n    }\n\n    if (targetProviderId) {\n      try {\n        await this.createConnection(targetProviderId);\n        this.emit('scaledUp', { providerId: targetProviderId, totalConnections: this.connections.size });\n      } catch (error) {\n        this.emit('scaleUpFailed', { providerId: targetProviderId, error });\n      }\n    }\n  }\n\n  private scaleDown(): void {\n    // Find the oldest, idle connection to remove\n    const idleConnections = Array.from(this.connections.values())\n      .filter(conn => !conn.isBusy && conn.isActive)\n      .sort((a, b) => a.lastUsed - b.lastUsed);\n\n    if (idleConnections.length > this.config.minConnections) {\n      const connectionToRemove = idleConnections[0];\n      this.destroyConnection(connectionToRemove.id);\n      this.emit('scaledDown', { \n        connectionId: connectionToRemove.id, \n        totalConnections: this.connections.size \n      });\n    }\n  }\n\n  // Cleanup\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupExpiredConnections();\n    }, 60000); // Check every minute\n  }\n\n  private cleanupExpiredConnections(): void {\n    const now = Date.now();\n    const connectionsToRemove: string[] = [];\n\n    for (const connection of this.connections.values()) {\n      // Remove connections that are too old\n      if (now - connection.createdAt > this.config.maxConnectionAge) {\n        connectionsToRemove.push(connection.id);\n      }\n      \n      // Remove idle connections that have been idle too long\n      else if (!connection.isBusy && \n               now - connection.lastUsed > this.config.idleTimeout) {\n        connectionsToRemove.push(connection.id);\n      }\n      \n      // Remove unhealthy connections\n      else if (!connection.isActive) {\n        connectionsToRemove.push(connection.id);\n      }\n    }\n\n    connectionsToRemove.forEach(id => this.destroyConnection(id));\n    \n    if (connectionsToRemove.length > 0) {\n      this.emit('cleanupCompleted', { removedConnections: connectionsToRemove.length });\n    }\n  }\n\n  // Metrics and Monitoring\n  private updateConnectionCounts(): void {\n    const connections = Array.from(this.connections.values());\n    \n    this.metrics.totalConnections = connections.length;\n    this.metrics.activeConnections = connections.filter(conn => conn.isActive).length;\n    this.metrics.busyConnections = connections.filter(conn => conn.isBusy).length;\n    this.metrics.idleConnections = connections.filter(conn => !conn.isBusy && conn.isActive).length;\n    this.metrics.poolUtilization = this.getUtilization();\n  }\n\n  private updateMetrics(event: string, duration?: number): void {\n    switch (event) {\n      case 'connectionAcquired':\n        this.metrics.totalRequests++;\n        this.metrics.successfulRequests++;\n        if (duration) {\n          this.metrics.averageResponseTime = \n            (this.metrics.averageResponseTime * 0.9) + (duration * 0.1);\n        }\n        break;\n        \n      case 'connectionError':\n        this.metrics.totalRequests++;\n        this.metrics.failedRequests++;\n        break;\n        \n      case 'connectionCreated':\n      case 'connectionReleased':\n        // Metrics updated in other methods\n        break;\n    }\n  }\n\n  // Public API\n  public getMetrics(): PoolMetrics {\n    return { ...this.metrics };\n  }\n\n  public getConnectionStatus(): Array<{\n    connection: PoolConnection;\n    provider: string;\n    status: 'active' | 'busy' | 'idle' | 'unhealthy';\n  }> {\n    return Array.from(this.connections.values()).map(connection => ({\n      connection,\n      provider: connection.providerId,\n      status: !connection.isActive ? 'unhealthy' :\n              connection.isBusy ? 'busy' :\n              'idle'\n    }));\n  }\n\n  public getProviderStats(): Map<string, {\n    totalConnections: number;\n    activeConnections: number;\n    busyConnections: number;\n    averageResponseTime: number;\n    healthScore: number;\n  }> {\n    const stats = new Map();\n\n    for (const [providerId, connectionIds] of this.providerPools) {\n      const connections = Array.from(connectionIds)\n        .map(id => this.connections.get(id)!)\n        .filter(conn => conn);\n\n      const activeConnections = connections.filter(conn => conn.isActive);\n      const busyConnections = connections.filter(conn => conn.isBusy);\n      \n      const avgResponseTime = activeConnections.length > 0 ?\n        activeConnections.reduce((sum, conn) => sum + conn.averageResponseTime, 0) / activeConnections.length : 0;\n      \n      const avgHealthScore = activeConnections.length > 0 ?\n        activeConnections.reduce((sum, conn) => sum + conn.healthScore, 0) / activeConnections.length : 0;\n\n      stats.set(providerId, {\n        totalConnections: connections.length,\n        activeConnections: activeConnections.length,\n        busyConnections: busyConnections.length,\n        averageResponseTime: avgResponseTime,\n        healthScore: avgHealthScore\n      });\n    }\n\n    return stats;\n  }\n\n  public async warmup(providerId: string, targetConnections: number): Promise<void> {\n    const existingConnections = this.providerPools.get(providerId)?.size || 0;\n    const connectionsToCreate = Math.max(0, targetConnections - existingConnections);\n\n    const creationPromises = Array.from({ length: connectionsToCreate }, () =>\n      this.createConnection(providerId)\n    );\n\n    await Promise.allSettled(creationPromises);\n    this.emit('warmupCompleted', { providerId, connectionsCreated: connectionsToCreate });\n  }\n\n  public drain(): Promise<void> {\n    return new Promise((resolve) => {\n      // Stop accepting new requests\n      this.requestQueue.forEach(request => {\n        clearTimeout(request.timeout);\n        request.reject(new Error('Pool is draining'));\n      });\n      this.requestQueue.length = 0;\n\n      // Wait for all busy connections to become idle\n      const checkIdle = () => {\n        const busyConnections = Array.from(this.connections.values())\n          .filter(conn => conn.isBusy);\n\n        if (busyConnections.length === 0) {\n          resolve();\n        } else {\n          setTimeout(checkIdle, 100);\n        }\n      };\n\n      checkIdle();\n    });\n  }\n\n  public destroy(): void {\n    // Clear all timers\n    if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);\n    if (this.scaleTimer) clearInterval(this.scaleTimer);\n    if (this.cleanupTimer) clearInterval(this.cleanupTimer);\n\n    // Reject any pending requests\n    this.requestQueue.forEach(request => {\n      clearTimeout(request.timeout);\n      request.reject(new Error('Pool destroyed'));\n    });\n\n    // Clear all data structures\n    this.connections.clear();\n    this.providerPools.clear();\n    this.requestQueue.length = 0;\n\n    this.removeAllListeners();\n  }\n}","import { EventEmitter } from 'events';\nimport winston from 'winston';\nimport { ethers } from 'ethers';\nimport { Connection, PublicKey, Transaction as SolanaTransaction, SystemProgram } from '@solana/web3.js';\nimport { RPCManager, RPCRequest } from './rpc-manager';\nimport { ConnectionPool } from './connection-pool';\n\nexport type SupportedChain = 'ethereum' | 'bsc' | 'polygon' | 'arbitrum' | 'optimism' | 'solana';\n\nexport interface ChainConfig {\n  chainId: number;\n  name: string;\n  symbol: string;\n  decimals: number;\n  rpcUrls: string[];\n  wsUrls: string[];\n  blockExplorerUrl: string;\n  nativeCurrency: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n  testnet?: boolean;\n  features: {\n    eip1559: boolean;\n    flashbots: boolean;\n    mev: boolean;\n    layer2: boolean;\n  };\n}\n\nexport interface TokenInfo {\n  address: string;\n  name: string;\n  symbol: string;\n  decimals: number;\n  logoURI?: string;\n  tags?: string[];\n  isNative?: boolean;\n}\n\nexport interface WalletBalance {\n  address: string;\n  balance: string;\n  balanceFormatted: string;\n  token?: TokenInfo;\n}\n\nexport interface GasSettings {\n  gasLimit?: string;\n  gasPrice?: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n  type?: number; // 0 = Legacy, 2 = EIP-1559\n}\n\nexport interface TransactionRequest {\n  to?: string;\n  from?: string;\n  value?: string;\n  data?: string;\n  gasSettings?: GasSettings;\n  nonce?: number;\n}\n\nexport interface TransactionReceipt {\n  hash: string;\n  blockNumber: number;\n  blockHash: string;\n  transactionIndex: number;\n  from: string;\n  to?: string;\n  gasUsed: string;\n  effectiveGasPrice: string;\n  status: number;\n  logs: TransactionLog[];\n  confirmations: number;\n}\n\nexport interface TransactionLog {\n  address: string;\n  topics: string[];\n  data: string;\n  blockNumber: number;\n  transactionHash: string;\n  logIndex: number;\n}\n\nexport interface BlockInfo {\n  number: number;\n  hash: string;\n  parentHash: string;\n  timestamp: number;\n  gasLimit: string;\n  gasUsed: string;\n  baseFeePerGas?: string;\n  transactions: string[];\n}\n\nexport interface SwapQuote {\n  inputToken: TokenInfo;\n  outputToken: TokenInfo;\n  inputAmount: string;\n  outputAmount: string;\n  route: Array<{\n    protocol: string;\n    percentage: number;\n    pool?: string;\n  }>;\n  gasEstimate: GasSettings;\n  priceImpact: string;\n  minimumReceived: string;\n  slippage: string;\n}\n\nexport interface ChainAbstractionConfig {\n  defaultChain: SupportedChain;\n  enabledChains: SupportedChain[];\n  rpcManager: any; // Reference to RPC manager\n  gasMultiplier: number;\n  maxGasPrice: string;\n  defaultSlippage: number;\n}\n\nexport interface ChainState {\n  latestBlock: number;\n  gasPrice: string;\n  isHealthy: boolean;\n  syncProgress: number;\n  peerCount: number;\n  pendingTransactions: number;\n}\n\nexport class ChainAbstraction extends EventEmitter {\n  private logger: winston.Logger;\n  private rpcManager: RPCManager;\n  private connectionPool: ConnectionPool;\n  private chains: Map<SupportedChain, ChainConfig> = new Map();\n  private providers: Map<SupportedChain, ethers.Provider> = new Map();\n  private tokenLists: Map<SupportedChain, Map<string, TokenInfo>> = new Map();\n  private gasOracles: Map<SupportedChain, any> = new Map();\n  private solanaConnection: Connection | null = null;\n\n  constructor(\n    rpcManager: RPCManager,\n    connectionPool: ConnectionPool,\n    logger: winston.Logger,\n    private config: ChainAbstractionConfig\n  ) {\n    super();\n    this.rpcManager = rpcManager;\n    this.connectionPool = connectionPool;\n    this.logger = logger;\n    \n    this.setupChainConfigs();\n    this.initializeProviders();\n    this.initializeTokenLists();\n    this.initializeGasOracles();\n  }\n\n  private setupChainConfigs(): void {\n    // Ethereum Mainnet\n    this.chains.set('ethereum', {\n      chainId: 1,\n      name: 'Ethereum',\n      symbol: 'ETH',\n      decimals: 18,\n      rpcUrls: [\n        'https://ethereum.publicnode.com',\n        'https://rpc.ankr.com/eth',\n        'https://eth-mainnet.public.blastapi.io'\n      ],\n      wsUrls: [\n        'wss://ethereum.publicnode.com',\n        'wss://rpc.ankr.com/eth/ws'\n      ],\n      blockExplorerUrl: 'https://etherscan.io',\n      nativeCurrency: {\n        name: 'Ether',\n        symbol: 'ETH',\n        decimals: 18\n      },\n      features: {\n        eip1559: true,\n        flashbots: true,\n        mev: true,\n        layer2: false\n      }\n    });\n\n    // BSC Mainnet\n    this.chains.set('bsc', {\n      chainId: 56,\n      name: 'Binance Smart Chain',\n      symbol: 'BNB',\n      decimals: 18,\n      rpcUrls: [\n        'https://bsc-dataseed1.binance.org',\n        'https://bsc-dataseed2.binance.org',\n        'https://rpc.ankr.com/bsc'\n      ],\n      wsUrls: [\n        'wss://bsc-ws-node.nariox.org:443',\n        'wss://bsc.publicnode.com'\n      ],\n      blockExplorerUrl: 'https://bscscan.com',\n      nativeCurrency: {\n        name: 'Binance Coin',\n        symbol: 'BNB',\n        decimals: 18\n      },\n      features: {\n        eip1559: false,\n        flashbots: false,\n        mev: true,\n        layer2: false\n      }\n    });\n\n    // Polygon\n    this.chains.set('polygon', {\n      chainId: 137,\n      name: 'Polygon',\n      symbol: 'MATIC',\n      decimals: 18,\n      rpcUrls: [\n        'https://polygon-rpc.com',\n        'https://rpc.ankr.com/polygon',\n        'https://polygon-mainnet.public.blastapi.io'\n      ],\n      wsUrls: [\n        'wss://polygon-bor.publicnode.com',\n        'wss://rpc.ankr.com/polygon/ws'\n      ],\n      blockExplorerUrl: 'https://polygonscan.com',\n      nativeCurrency: {\n        name: 'Polygon',\n        symbol: 'MATIC',\n        decimals: 18\n      },\n      features: {\n        eip1559: true,\n        flashbots: false,\n        mev: true,\n        layer2: true\n      }\n    });\n\n    // Arbitrum One\n    this.chains.set('arbitrum', {\n      chainId: 42161,\n      name: 'Arbitrum One',\n      symbol: 'ETH',\n      decimals: 18,\n      rpcUrls: [\n        'https://arb1.arbitrum.io/rpc',\n        'https://rpc.ankr.com/arbitrum',\n        'https://arbitrum-mainnet.public.blastapi.io'\n      ],\n      wsUrls: [\n        'wss://arb1.arbitrum.io/ws',\n        'wss://rpc.ankr.com/arbitrum/ws'\n      ],\n      blockExplorerUrl: 'https://arbiscan.io',\n      nativeCurrency: {\n        name: 'Ether',\n        symbol: 'ETH',\n        decimals: 18\n      },\n      features: {\n        eip1559: true,\n        flashbots: false,\n        mev: true,\n        layer2: true\n      }\n    });\n\n    // Optimism\n    this.chains.set('optimism', {\n      chainId: 10,\n      name: 'Optimism',\n      symbol: 'ETH',\n      decimals: 18,\n      rpcUrls: [\n        'https://mainnet.optimism.io',\n        'https://rpc.ankr.com/optimism',\n        'https://optimism-mainnet.public.blastapi.io'\n      ],\n      wsUrls: [\n        'wss://optimism-mainnet.public.blastapi.io',\n        'wss://rpc.ankr.com/optimism/ws'\n      ],\n      blockExplorerUrl: 'https://optimistic.etherscan.io',\n      nativeCurrency: {\n        name: 'Ether',\n        symbol: 'ETH',\n        decimals: 18\n      },\n      features: {\n        eip1559: true,\n        flashbots: false,\n        mev: true,\n        layer2: true\n      }\n    });\n\n    // Solana\n    this.chains.set('solana', {\n      chainId: 101, // Solana mainnet-beta\n      name: 'Solana',\n      symbol: 'SOL',\n      decimals: 9,\n      rpcUrls: [\n        'https://api.mainnet-beta.solana.com',\n        'https://rpc.ankr.com/solana',\n        'https://solana-api.projectserum.com'\n      ],\n      wsUrls: [\n        'wss://api.mainnet-beta.solana.com',\n        'wss://rpc.ankr.com/solana/ws'\n      ],\n      blockExplorerUrl: 'https://solscan.io',\n      nativeCurrency: {\n        name: 'Solana',\n        symbol: 'SOL',\n        decimals: 9\n      },\n      features: {\n        eip1559: false,\n        flashbots: false,\n        mev: true,\n        layer2: false\n      }\n    });\n\n    this.logger.info('Chain configurations initialized', {\n      chains: Array.from(this.chains.keys())\n    });\n  }\n\n  private async initializeProviders(): Promise<void> {\n    for (const [chainName, chainConfig] of this.chains) {\n      if (chainName === 'solana') {\n        // Solana uses different provider architecture\n        continue;\n      }\n\n      // Create ethers provider with fallback\n      const provider = new ethers.FallbackProvider(\n        chainConfig.rpcUrls.map((url, index) => ({\n          provider: new ethers.JsonRpcProvider(url),\n          priority: index + 1,\n          weight: 1\n        }))\n      );\n\n      this.providers.set(chainName as SupportedChain, provider);\n    }\n  }\n\n  private initializeTokenLists(): void {\n    // Initialize common tokens for each chain\n    const commonTokens = {\n      ethereum: [\n        {\n          address: '0xA0b86a33E6441e27a4E54E7cb03FA3a84F8C0F4F',\n          name: 'USD Coin',\n          symbol: 'USDC',\n          decimals: 6,\n          logoURI: 'https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png'\n        },\n        {\n          address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',\n          name: 'Tether USD',\n          symbol: 'USDT',\n          decimals: 6,\n          logoURI: 'https://assets.coingecko.com/coins/images/325/thumb/Tether-logo.png'\n        },\n        {\n          address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n          name: 'Wrapped Ether',\n          symbol: 'WETH',\n          decimals: 18,\n          logoURI: 'https://assets.coingecko.com/coins/images/2518/thumb/weth.png'\n        }\n      ],\n      bsc: [\n        {\n          address: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',\n          name: 'USD Coin',\n          symbol: 'USDC',\n          decimals: 18,\n          logoURI: 'https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png'\n        },\n        {\n          address: '0x55d398326f99059fF775485246999027B3197955',\n          name: 'Tether USD',\n          symbol: 'USDT',\n          decimals: 18,\n          logoURI: 'https://assets.coingecko.com/coins/images/325/thumb/Tether-logo.png'\n        },\n        {\n          address: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n          name: 'Wrapped BNB',\n          symbol: 'WBNB',\n          decimals: 18,\n          logoURI: 'https://assets.coingecko.com/coins/images/825/thumb/bnb-icon2_2x.png'\n        }\n      ]\n    };\n\n    for (const [chain, tokens] of Object.entries(commonTokens)) {\n      const tokenMap = new Map<string, TokenInfo>();\n      for (const token of tokens) {\n        tokenMap.set(token.address.toLowerCase(), token);\n      }\n      this.tokenLists.set(chain as SupportedChain, tokenMap);\n    }\n  }\n\n  private initializeGasOracles(): void {\n    // Gas price oracles for different chains\n    const gasOracles = {\n      ethereum: {\n        fast: () => this.getGasPrice('ethereum', 'fast'),\n        standard: () => this.getGasPrice('ethereum', 'standard'),\n        safe: () => this.getGasPrice('ethereum', 'safe')\n      },\n      bsc: {\n        fast: () => this.getGasPrice('bsc', 'fast'),\n        standard: () => this.getGasPrice('bsc', 'standard'),\n        safe: () => this.getGasPrice('bsc', 'safe')\n      }\n    };\n\n    for (const [chain, oracle] of Object.entries(gasOracles)) {\n      this.gasOracles.set(chain as SupportedChain, oracle);\n    }\n  }\n\n  // Public API Methods\n\n  public getChainConfig(chain: SupportedChain): ChainConfig | undefined {\n    return this.chains.get(chain);\n  }\n\n  public getSupportedChains(): SupportedChain[] {\n    return Array.from(this.chains.keys());\n  }\n\n  public isChainSupported(chain: string): chain is SupportedChain {\n    return this.chains.has(chain as SupportedChain);\n  }\n\n  public async getProvider(chain: SupportedChain): Promise<ethers.Provider> {\n    const provider = this.providers.get(chain);\n    if (!provider) {\n      throw new Error(`Provider not available for chain: ${chain}`);\n    }\n    return provider;\n  }\n\n  // Block and Transaction Methods\n\n  public async getBlockNumber(chain: SupportedChain): Promise<number> {\n    if (chain === 'solana') {\n      return this.getSolanaSlot();\n    }\n\n    const provider = await this.getProvider(chain);\n    return provider.getBlockNumber();\n  }\n\n  public async getBlock(chain: SupportedChain, blockNumber: number): Promise<BlockInfo> {\n    if (chain === 'solana') {\n      return this.getSolanaBlock(blockNumber);\n    }\n\n    const provider = await this.getProvider(chain);\n    const block = await provider.getBlock(blockNumber);\n    \n    if (!block) {\n      throw new Error(`Block ${blockNumber} not found on ${chain}`);\n    }\n\n    return {\n      number: block.number,\n      hash: block.hash,\n      parentHash: block.parentHash,\n      timestamp: block.timestamp,\n      gasLimit: block.gasLimit.toString(),\n      gasUsed: block.gasUsed.toString(),\n      baseFeePerGas: block.baseFeePerGas?.toString(),\n      transactions: block.transactions\n    };\n  }\n\n  public async getTransaction(chain: SupportedChain, hash: string): Promise<TransactionReceipt | null> {\n    if (chain === 'solana') {\n      return this.getSolanaTransaction(hash);\n    }\n\n    const provider = await this.getProvider(chain);\n    const receipt = await provider.getTransactionReceipt(hash);\n    \n    if (!receipt) return null;\n\n    return {\n      hash: receipt.hash,\n      blockNumber: receipt.blockNumber,\n      blockHash: receipt.blockHash,\n      transactionIndex: receipt.index,\n      from: receipt.from,\n      to: receipt.to,\n      gasUsed: receipt.gasUsed.toString(),\n      effectiveGasPrice: receipt.gasPrice.toString(),\n      status: receipt.status || 0,\n      logs: receipt.logs.map(log => ({\n        address: log.address,\n        topics: log.topics,\n        data: log.data,\n        blockNumber: log.blockNumber,\n        transactionHash: log.transactionHash,\n        logIndex: log.index\n      })),\n      confirmations: receipt.confirmations\n    };\n  }\n\n  // Gas Management\n\n  public async getGasPrice(chain: SupportedChain, speed: 'fast' | 'standard' | 'safe' = 'standard'): Promise<GasSettings> {\n    if (chain === 'solana') {\n      return { gasLimit: '200000' }; // Solana uses compute units\n    }\n\n    const provider = await this.getProvider(chain);\n    const chainConfig = this.getChainConfig(chain)!;\n\n    if (chainConfig.features.eip1559) {\n      const feeData = await provider.getFeeData();\n      \n      let maxPriorityFeePerGas = feeData.maxPriorityFeePerGas || ethers.parseUnits('2', 'gwei');\n      let maxFeePerGas = feeData.maxFeePerGas || ethers.parseUnits('20', 'gwei');\n\n      // Adjust based on speed\n      const multipliers = {\n        safe: 0.8,\n        standard: 1.0,\n        fast: 1.2\n      };\n\n      const multiplier = multipliers[speed];\n      maxPriorityFeePerGas = (maxPriorityFeePerGas * BigInt(Math.floor(multiplier * 100))) / BigInt(100);\n      maxFeePerGas = (maxFeePerGas * BigInt(Math.floor(multiplier * 100))) / BigInt(100);\n\n      return {\n        type: 2,\n        maxFeePerGas: maxFeePerGas.toString(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas.toString()\n      };\n    } else {\n      const gasPrice = await provider.getFeeData();\n      let price = gasPrice.gasPrice || ethers.parseUnits('5', 'gwei');\n\n      // Adjust based on speed\n      const multipliers = {\n        safe: 0.8,\n        standard: 1.0,\n        fast: 1.2\n      };\n\n      const multiplier = multipliers[speed];\n      price = (price * BigInt(Math.floor(multiplier * 100))) / BigInt(100);\n\n      return {\n        type: 0,\n        gasPrice: price.toString()\n      };\n    }\n  }\n\n  public async estimateGas(chain: SupportedChain, transaction: TransactionRequest): Promise<string> {\n    if (chain === 'solana') {\n      return '200000'; // Estimated compute units for Solana\n    }\n\n    const provider = await this.getProvider(chain);\n    const gasEstimate = await provider.estimateGas(transaction);\n    \n    // Apply gas multiplier for safety\n    const multiplied = (gasEstimate * BigInt(Math.floor(this.config.gasMultiplier * 100))) / BigInt(100);\n    \n    return multiplied.toString();\n  }\n\n  // Token Management\n\n  public async getTokenInfo(chain: SupportedChain, address: string): Promise<TokenInfo | null> {\n    const tokenList = this.tokenLists.get(chain);\n    const cachedToken = tokenList?.get(address.toLowerCase());\n    \n    if (cachedToken) {\n      return cachedToken;\n    }\n\n    // Fetch from chain if not cached\n    return this.fetchTokenInfoFromChain(chain, address);\n  }\n\n  private async fetchTokenInfoFromChain(chain: SupportedChain, address: string): Promise<TokenInfo | null> {\n    if (chain === 'solana') {\n      return this.fetchSolanaTokenInfo(address);\n    }\n\n    try {\n      const provider = await this.getProvider(chain);\n      \n      // ERC-20 contract ABI for basic info\n      const abi = [\n        'function name() view returns (string)',\n        'function symbol() view returns (string)',\n        'function decimals() view returns (uint8)'\n      ];\n\n      const contract = new ethers.Contract(address, abi, provider);\n      \n      const [name, symbol, decimals] = await Promise.all([\n        contract.name(),\n        contract.symbol(),\n        contract.decimals()\n      ]);\n\n      const tokenInfo: TokenInfo = {\n        address: address.toLowerCase(),\n        name,\n        symbol,\n        decimals\n      };\n\n      // Cache the token info\n      const tokenList = this.tokenLists.get(chain);\n      if (tokenList) {\n        tokenList.set(address.toLowerCase(), tokenInfo);\n      }\n\n      return tokenInfo;\n    } catch (error) {\n      console.error(`Failed to fetch token info for ${address} on ${chain}:`, error);\n      return null;\n    }\n  }\n\n  public async getTokenBalance(chain: SupportedChain, tokenAddress: string, walletAddress: string): Promise<string> {\n    if (chain === 'solana') {\n      return this.getSolanaTokenBalance(tokenAddress, walletAddress);\n    }\n\n    const provider = await this.getProvider(chain);\n    \n    // Check if it's native token\n    if (tokenAddress === 'native' || tokenAddress === ethers.ZeroAddress) {\n      const balance = await provider.getBalance(walletAddress);\n      return balance.toString();\n    }\n\n    // ERC-20 token\n    const abi = ['function balanceOf(address) view returns (uint256)'];\n    const contract = new ethers.Contract(tokenAddress, abi, provider);\n    const balance = await contract.balanceOf(walletAddress);\n    \n    return balance.toString();\n  }\n\n  // DEX Integration\n\n  public async getSwapQuote(\n    chain: SupportedChain,\n    inputToken: string,\n    outputToken: string,\n    inputAmount: string,\n    slippage: number = this.config.defaultSlippage\n  ): Promise<SwapQuote> {\n    if (chain === 'solana') {\n      return this.getSolanaSwapQuote(inputToken, outputToken, inputAmount, slippage);\n    }\n\n    // Use 0x API for EVM chains\n    return this.get0xSwapQuote(chain, inputToken, outputToken, inputAmount, slippage);\n  }\n\n  public async executeSwap(\n    chain: SupportedChain,\n    quote: SwapQuote,\n    signer: ethers.Signer\n  ): Promise<TransactionReceipt> {\n    if (chain === 'solana') {\n      return this.executeSolanaSwap(quote, signer);\n    }\n\n    // Execute EVM swap\n    return this.executeEVMSwap(chain, quote, signer);\n  }\n\n  // Cross-chain bridge operations\n\n  public async getBridgeQuote(\n    fromChain: SupportedChain,\n    toChain: SupportedChain,\n    token: string,\n    amount: string\n  ): Promise<any> {\n    // Implement bridge quote logic (Stargate, LayerZero, etc.)\n    throw new Error('Bridge operations not yet implemented');\n  }\n\n  // Utility Methods\n\n  public formatAmount(amount: string, decimals: number): string {\n    return ethers.formatUnits(amount, decimals);\n  }\n\n  public parseAmount(amount: string, decimals: number): string {\n    return ethers.parseUnits(amount, decimals).toString();\n  }\n\n  public isValidAddress(chain: SupportedChain, address: string): boolean {\n    if (chain === 'solana') {\n      // Solana address validation\n      return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);\n    }\n\n    return ethers.isAddress(address);\n  }\n\n  // Private helper methods for Solana\n\n  private async getSolanaSlot(): Promise<number> {\n    // Implement Solana slot fetching\n    throw new Error('Solana slot fetching not implemented');\n  }\n\n  private async getSolanaBlock(slot: number): Promise<BlockInfo> {\n    // Implement Solana block fetching\n    throw new Error('Solana block fetching not implemented');\n  }\n\n  private async getSolanaTransaction(signature: string): Promise<TransactionReceipt | null> {\n    // Implement Solana transaction fetching\n    throw new Error('Solana transaction fetching not implemented');\n  }\n\n  private async fetchSolanaTokenInfo(mint: string): Promise<TokenInfo | null> {\n    // Implement Solana token info fetching\n    throw new Error('Solana token info fetching not implemented');\n  }\n\n  private async getSolanaTokenBalance(mint: string, owner: string): Promise<string> {\n    // Implement Solana token balance fetching\n    throw new Error('Solana token balance fetching not implemented');\n  }\n\n  private async getSolanaSwapQuote(\n    inputMint: string,\n    outputMint: string,\n    amount: string,\n    slippage: number\n  ): Promise<SwapQuote> {\n    // Implement Jupiter API integration for Solana swaps\n    throw new Error('Solana swap quotes not implemented');\n  }\n\n  private async executeSolanaSwap(quote: SwapQuote, signer: any): Promise<TransactionReceipt> {\n    // Implement Solana swap execution\n    throw new Error('Solana swap execution not implemented');\n  }\n\n  // Private helper methods for EVM chains\n\n  private async get0xSwapQuote(\n    chain: SupportedChain,\n    inputToken: string,\n    outputToken: string,\n    inputAmount: string,\n    slippage: number\n  ): Promise<SwapQuote> {\n    // Implement 0x API integration\n    const chainConfig = this.getChainConfig(chain)!;\n    \n    // Mock implementation - replace with actual 0x API call\n    const inputTokenInfo = await this.getTokenInfo(chain, inputToken);\n    const outputTokenInfo = await this.getTokenInfo(chain, outputToken);\n    \n    if (!inputTokenInfo || !outputTokenInfo) {\n      throw new Error('Token info not found');\n    }\n\n    // Simulate price calculation (replace with real API)\n    const outputAmount = (BigInt(inputAmount) * BigInt(98)) / BigInt(100); // 2% simulated slippage\n\n    return {\n      inputToken: inputTokenInfo,\n      outputToken: outputTokenInfo,\n      inputAmount,\n      outputAmount: outputAmount.toString(),\n      route: [\n        {\n          protocol: 'Uniswap V3',\n          percentage: 100\n        }\n      ],\n      gasEstimate: await this.getGasPrice(chain, 'fast'),\n      priceImpact: '0.1',\n      minimumReceived: ((outputAmount * BigInt(10000 - Math.floor(slippage * 100))) / BigInt(10000)).toString(),\n      slippage: slippage.toString()\n    };\n  }\n\n  private async executeEVMSwap(\n    chain: SupportedChain,\n    quote: SwapQuote,\n    signer: ethers.Signer\n  ): Promise<TransactionReceipt> {\n    // Implement EVM swap execution using 0x or DEX router\n    throw new Error('EVM swap execution not implemented');\n  }\n\n  // Event methods\n\n  public async waitForTransaction(\n    chain: SupportedChain,\n    hash: string,\n    confirmations: number = 1\n  ): Promise<TransactionReceipt | null> {\n    if (chain === 'solana') {\n      // Implement Solana transaction confirmation waiting\n      throw new Error('Solana transaction waiting not implemented');\n    }\n\n    const provider = await this.getProvider(chain);\n    const receipt = await provider.waitForTransaction(hash, confirmations);\n    \n    if (!receipt) return null;\n\n    return {\n      hash: receipt.hash,\n      blockNumber: receipt.blockNumber,\n      blockHash: receipt.blockHash,\n      transactionIndex: receipt.index,\n      from: receipt.from,\n      to: receipt.to,\n      gasUsed: receipt.gasUsed.toString(),\n      effectiveGasPrice: receipt.gasPrice.toString(),\n      status: receipt.status || 0,\n      logs: receipt.logs.map(log => ({\n        address: log.address,\n        topics: log.topics,\n        data: log.data,\n        blockNumber: log.blockNumber,\n        transactionHash: log.transactionHash,\n        logIndex: log.index\n      })),\n      confirmations: receipt.confirmations\n    };\n  }\n\n  public destroy(): void {\n    // Clean up providers and connections\n    this.providers.clear();\n    this.chains.clear();\n    this.tokenLists.clear();\n    this.gasOracles.clear();\n    this.removeAllListeners();\n  }\n}","import { EventEmitter } from 'events';\nimport winston from 'winston';\nimport axios from 'axios';\nimport { ChainAbstraction, TokenInfo, GasEstimate } from './chain-abstraction';\n\nexport interface DEXConfig {\n  id: string;\n  name: string;\n  chain: string;\n  type: 'uniswap-v2' | 'uniswap-v3' | 'curve' | 'balancer' | 'jupiter' | '1inch';\n  routerAddress?: string;\n  factoryAddress?: string;\n  apiUrl?: string;\n  apiKey?: string;\n  fee: number; // in basis points (100 = 1%)\n  gasMultiplier: number;\n  isActive: boolean;\n  supportedFeatures: string[];\n}\n\nexport interface SwapRoute {\n  dex: string;\n  inputToken: TokenInfo;\n  outputToken: TokenInfo;\n  inputAmount: string;\n  outputAmount: string;\n  expectedOutputAmount: string;\n  minimumOutputAmount: string;\n  price: string;\n  priceImpact: string;\n  slippage: string;\n  gasEstimate: GasEstimate;\n  route: RouteStep[];\n  confidence: number; // 0-100\n  executionTime: number; // estimated ms\n}\n\nexport interface RouteStep {\n  dex: string;\n  pool: string;\n  tokenIn: TokenInfo;\n  tokenOut: TokenInfo;\n  amountIn: string;\n  amountOut: string;\n  fee: number;\n  priceImpact: string;\n}\n\nexport interface SwapQuoteRequest {\n  inputToken: string;\n  outputToken: string;\n  amount: string;\n  slippage: number; // 0.5 = 0.5%\n  chain: string;\n  userAddress?: string;\n  maxHops?: number;\n  excludeDEXes?: string[];\n  includeDEXes?: string[];\n  preferredDEX?: string;\n  gasPrice?: string;\n}\n\nexport interface SwapQuoteResponse {\n  routes: SwapRoute[];\n  bestRoute: SwapRoute;\n  estimatedGas: string;\n  totalGasCost: string;\n  netOutput: string; // output after gas costs\n  executionTime: number;\n  timestamp: number;\n}\n\nexport interface DEXStats {\n  totalVolume24h: string;\n  totalLiquidity: string;\n  successRate: number;\n  averageSlippage: number;\n  averageGasCost: string;\n  responseTime: number;\n  lastUpdated: number;\n}\n\nexport interface AggregatorStats {\n  totalQuotes: number;\n  successfulQuotes: number;\n  averageResponseTime: number;\n  totalVolumeRouted: string;\n  activeDEXes: number;\n  chainStats: Map<string, {\n    quotes: number;\n    volume: string;\n    averageSlippage: number;\n  }>;\n}\n\nexport class DEXAggregator extends EventEmitter {\n  private logger: winston.Logger;\n  private chainAbstraction: ChainAbstraction;\n  private dexConfigs: Map<string, DEXConfig> = new Map();\n  private tokenLists: Map<string, TokenInfo[]> = new Map(); // chain -> tokens\n  private priceCache: Map<string, { price: number; timestamp: number }> = new Map();\n  private routeCache: Map<string, { routes: SwapRoute[]; timestamp: number }> = new Map();\n  private dexStats: Map<string, DEXStats> = new Map();\n  private stats: AggregatorStats;\n\n  constructor(chainAbstraction: ChainAbstraction, logger: winston.Logger) {\n    super();\n    this.chainAbstraction = chainAbstraction;\n    this.logger = logger;\n    \n    this.stats = {\n      totalQuotes: 0,\n      successfulQuotes: 0,\n      averageResponseTime: 0,\n      totalVolumeRouted: '0',\n      activeDEXes: 0,\n      chainStats: new Map()\n    };\n\n    this.setupDEXConfigs();\n    this.loadTokenLists();\n    this.startStatsCollection();\n  }\n\n  private setupDEXConfigs(): void {\n    // Ethereum DEXes\n    this.addDEXConfig({\n      id: 'uniswap-v3-eth',\n      name: 'Uniswap V3',\n      chain: 'ethereum',\n      type: 'uniswap-v3',\n      routerAddress: '0xE592427A0AEce92De3Edee1F18E0157C05861564',\n      factoryAddress: '0x1F98431c8aD98523631AE4a59f267346ea31F984',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.2,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input', 'exact-output']\n    });\n\n    this.addDEXConfig({\n      id: 'uniswap-v2-eth',\n      name: 'Uniswap V2',\n      chain: 'ethereum',\n      type: 'uniswap-v2',\n      routerAddress: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',\n      factoryAddress: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input']\n    });\n\n    this.addDEXConfig({\n      id: '1inch-eth',\n      name: '1inch',\n      chain: 'ethereum',\n      type: '1inch',\n      apiUrl: 'https://api.1inch.dev/swap/v5.2/1',\n      apiKey: process.env.ONEINCH_API_KEY,\n      fee: 0, // 1inch handles fees internally\n      gasMultiplier: 1.1,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-dex', 'gas-optimization', 'partial-fill']\n    });\n\n    // BSC DEXes\n    this.addDEXConfig({\n      id: 'pancakeswap-v3-bsc',\n      name: 'PancakeSwap V3',\n      chain: 'bsc',\n      type: 'uniswap-v3',\n      routerAddress: '0x13f4EA83D0bd40E75C8222255bc855a974568Dd4',\n      factoryAddress: '0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865',\n      fee: 25, // 0.25%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input', 'exact-output']\n    });\n\n    this.addDEXConfig({\n      id: 'pancakeswap-v2-bsc',\n      name: 'PancakeSwap V2',\n      chain: 'bsc',\n      type: 'uniswap-v2',\n      routerAddress: '0x10ED43C718714eb63d5aA57B78B54704E256024E',\n      factoryAddress: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',\n      fee: 25, // 0.25%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input']\n    });\n\n    this.addDEXConfig({\n      id: '1inch-bsc',\n      name: '1inch',\n      chain: 'bsc',\n      type: '1inch',\n      apiUrl: 'https://api.1inch.dev/swap/v5.2/56',\n      apiKey: process.env.ONEINCH_API_KEY,\n      fee: 0,\n      gasMultiplier: 1.1,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-dex', 'gas-optimization']\n    });\n\n    // Polygon DEXes\n    this.addDEXConfig({\n      id: 'uniswap-v3-polygon',\n      name: 'Uniswap V3',\n      chain: 'polygon',\n      type: 'uniswap-v3',\n      routerAddress: '0xE592427A0AEce92De3Edee1F18E0157C05861564',\n      factoryAddress: '0x1F98431c8aD98523631AE4a59f267346ea31F984',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input', 'exact-output']\n    });\n\n    this.addDEXConfig({\n      id: 'quickswap-polygon',\n      name: 'QuickSwap',\n      chain: 'polygon',\n      type: 'uniswap-v2',\n      routerAddress: '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff',\n      factoryAddress: '0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input']\n    });\n\n    // Arbitrum DEXes\n    this.addDEXConfig({\n      id: 'uniswap-v3-arbitrum',\n      name: 'Uniswap V3',\n      chain: 'arbitrum',\n      type: 'uniswap-v3',\n      routerAddress: '0xE592427A0AEce92De3Edee1F18E0157C05861564',\n      factoryAddress: '0x1F98431c8aD98523631AE4a59f267346ea31F984',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input', 'exact-output']\n    });\n\n    this.addDEXConfig({\n      id: 'camelot-arbitrum',\n      name: 'Camelot',\n      chain: 'arbitrum',\n      type: 'uniswap-v2',\n      routerAddress: '0xc873fEcbd354f5A56E00E710B90EF4201db2448d',\n      factoryAddress: '0x6EcCab422D763aC031210895C81787E87B91425a',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input']\n    });\n\n    // Optimism DEXes\n    this.addDEXConfig({\n      id: 'uniswap-v3-optimism',\n      name: 'Uniswap V3',\n      chain: 'optimism',\n      type: 'uniswap-v3',\n      routerAddress: '0xE592427A0AEce92De3Edee1F18E0157C05861564',\n      factoryAddress: '0x1F98431c8aD98523631AE4a59f267346ea31F984',\n      fee: 30, // 0.3%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input', 'exact-output']\n    });\n\n    // Solana DEXes\n    this.addDEXConfig({\n      id: 'jupiter-solana',\n      name: 'Jupiter',\n      chain: 'solana',\n      type: 'jupiter',\n      apiUrl: 'https://quote-api.jup.ag/v6',\n      fee: 0, // Jupiter aggregates multiple DEXes\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-dex', 'exact-input', 'exact-output']\n    });\n\n    this.addDEXConfig({\n      id: 'raydium-solana',\n      name: 'Raydium',\n      chain: 'solana',\n      type: 'uniswap-v2', // Similar AMM model\n      apiUrl: 'https://api.raydium.io/v2',\n      fee: 25, // 0.25%\n      gasMultiplier: 1.0,\n      isActive: true,\n      supportedFeatures: ['price-quotes', 'multi-hop', 'exact-input']\n    });\n\n    this.logger.info('DEX configurations initialized', {\n      totalDEXes: this.dexConfigs.size,\n      chains: Array.from(new Set(Array.from(this.dexConfigs.values()).map(d => d.chain)))\n    });\n  }\n\n  private addDEXConfig(config: DEXConfig): void {\n    this.dexConfigs.set(config.id, config);\n    this.dexStats.set(config.id, {\n      totalVolume24h: '0',\n      totalLiquidity: '0',\n      successRate: 100,\n      averageSlippage: 0,\n      averageGasCost: '0',\n      responseTime: 0,\n      lastUpdated: Date.now()\n    });\n  }\n\n  private async loadTokenLists(): Promise<void> {\n    // Load popular token lists for each chain\n    const tokenListUrls = {\n      ethereum: 'https://tokens.uniswap.org',\n      bsc: 'https://tokens.pancakeswap.finance/pancakeswap-extended.json',\n      polygon: 'https://unpkg.com/quickswap-default-token-list@1.0.71/build/quickswap-default.tokenlist.json',\n      arbitrum: 'https://bridge.arbitrum.io/token-list-42161.json',\n      optimism: 'https://static.optimism.io/optimism.tokenlist.json'\n    };\n\n    for (const [chain, url] of Object.entries(tokenListUrls)) {\n      try {\n        const response = await axios.get(url, { timeout: 10000 });\n        const tokenList = response.data.tokens || response.data;\n        \n        // Filter and format tokens for our use\n        const formattedTokens = tokenList\n          .filter((token: any) => token.chainId === this.getChainId(chain))\n          .map((token: any) => ({\n            address: token.address,\n            symbol: token.symbol,\n            name: token.name,\n            decimals: token.decimals,\n            logoURI: token.logoURI,\n            chainId: token.chainId\n          }));\n\n        this.tokenLists.set(chain, formattedTokens);\n        \n        this.logger.info('Token list loaded', {\n          chain,\n          tokenCount: formattedTokens.length\n        });\n      } catch (error: any) {\n        this.logger.warn('Failed to load token list', {\n          chain,\n          url,\n          error: error.message\n        });\n      }\n    }\n  }\n\n  private getChainId(chain: string): number {\n    const chainIds: Record<string, number> = {\n      ethereum: 1,\n      bsc: 56,\n      polygon: 137,\n      arbitrum: 42161,\n      optimism: 10,\n      solana: 101\n    };\n    return chainIds[chain] || 1;\n  }\n\n  // Main quote aggregation method\n  async getSwapQuote(request: SwapQuoteRequest): Promise<SwapQuoteResponse> {\n    const startTime = Date.now();\n    \n    try {\n      // Validate request\n      await this.validateQuoteRequest(request);\n\n      // Get available DEXes for the chain\n      const availableDEXes = this.getAvailableDEXes(request.chain, request.excludeDEXes, request.includeDEXes);\n      \n      if (availableDEXes.length === 0) {\n        throw new Error(`No available DEXes for chain: ${request.chain}`);\n      }\n\n      // Get quotes from multiple DEXes in parallel\n      const quotePromises = availableDEXes.map(dex => \n        this.getQuoteFromDEX(dex, request).catch(error => {\n          this.logger.warn('DEX quote failed', {\n            dex: dex.id,\n            error: error.message\n          });\n          return null;\n        })\n      );\n\n      const quoteResults = await Promise.allSettled(quotePromises);\n      const successfulQuotes = quoteResults\n        .filter((result): result is PromiseFulfilledResult<SwapRoute | null> => \n          result.status === 'fulfilled' && result.value !== null)\n        .map(result => result.value!);\n\n      if (successfulQuotes.length === 0) {\n        throw new Error('No successful quotes from any DEX');\n      }\n\n      // Find the best route considering price, gas costs, and confidence\n      const bestRoute = this.selectBestRoute(successfulQuotes, request);\n\n      // Update statistics\n      this.updateStats(request.chain, successfulQuotes.length > 0);\n\n      const response: SwapQuoteResponse = {\n        routes: successfulQuotes.sort((a, b) => parseFloat(b.outputAmount) - parseFloat(a.outputAmount)),\n        bestRoute,\n        estimatedGas: bestRoute.gasEstimate.gasLimit,\n        totalGasCost: bestRoute.gasEstimate.totalCost,\n        netOutput: this.calculateNetOutput(bestRoute),\n        executionTime: Date.now() - startTime,\n        timestamp: Date.now()\n      };\n\n      this.emit('quoteGenerated', { request, response, executionTime: response.executionTime });\n      \n      return response;\n    } catch (error: any) {\n      this.updateStats(request.chain, false);\n      this.logger.error('Failed to get swap quote', {\n        request,\n        error: error.message,\n        executionTime: Date.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  private async validateQuoteRequest(request: SwapQuoteRequest): Promise<void> {\n    // Validate chain\n    if (!this.chainAbstraction.getSupportedChains().includes(request.chain)) {\n      throw new Error(`Unsupported chain: ${request.chain}`);\n    }\n\n    // Validate addresses\n    if (!this.chainAbstraction.isValidAddress(request.chain, request.inputToken)) {\n      throw new Error(`Invalid input token address: ${request.inputToken}`);\n    }\n\n    if (!this.chainAbstraction.isValidAddress(request.chain, request.outputToken)) {\n      throw new Error(`Invalid output token address: ${request.outputToken}`);\n    }\n\n    // Validate amount\n    if (parseFloat(request.amount) <= 0) {\n      throw new Error('Amount must be greater than 0');\n    }\n\n    // Validate slippage\n    if (request.slippage < 0 || request.slippage > 50) {\n      throw new Error('Slippage must be between 0 and 50%');\n    }\n  }\n\n  private getAvailableDEXes(\n    chain: string, \n    excludeDEXes?: string[], \n    includeDEXes?: string[]\n  ): DEXConfig[] {\n    let dexes = Array.from(this.dexConfigs.values())\n      .filter(dex => dex.chain === chain && dex.isActive);\n\n    if (includeDEXes && includeDEXes.length > 0) {\n      dexes = dexes.filter(dex => includeDEXes.includes(dex.id));\n    }\n\n    if (excludeDEXes && excludeDEXes.length > 0) {\n      dexes = dexes.filter(dex => !excludeDEXes.includes(dex.id));\n    }\n\n    return dexes;\n  }\n\n  private async getQuoteFromDEX(dex: DEXConfig, request: SwapQuoteRequest): Promise<SwapRoute | null> {\n    const startTime = Date.now();\n\n    try {\n      let route: SwapRoute;\n\n      switch (dex.type) {\n        case '1inch':\n          route = await this.get1inchQuote(dex, request);\n          break;\n        case 'jupiter':\n          route = await this.getJupiterQuote(dex, request);\n          break;\n        case 'uniswap-v3':\n          route = await this.getUniswapV3Quote(dex, request);\n          break;\n        case 'uniswap-v2':\n          route = await this.getUniswapV2Quote(dex, request);\n          break;\n        default:\n          throw new Error(`Unsupported DEX type: ${dex.type}`);\n      }\n\n      // Update DEX stats\n      const responseTime = Date.now() - startTime;\n      this.updateDEXStats(dex.id, responseTime, true);\n\n      return route;\n    } catch (error: any) {\n      const responseTime = Date.now() - startTime;\n      this.updateDEXStats(dex.id, responseTime, false);\n      throw error;\n    }\n  }\n\n  private async get1inchQuote(dex: DEXConfig, request: SwapQuoteRequest): Promise<SwapRoute> {\n    const params = new URLSearchParams({\n      fromTokenAddress: request.inputToken,\n      toTokenAddress: request.outputToken,\n      amount: request.amount,\n      slippage: request.slippage.toString(),\n      disableEstimate: 'false',\n      allowPartialFill: 'true'\n    });\n\n    if (request.userAddress) {\n      params.append('fromAddress', request.userAddress);\n    }\n\n    const response = await axios.get(`${dex.apiUrl}/quote?${params}`, {\n      headers: {\n        'Authorization': `Bearer ${dex.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      timeout: 10000\n    });\n\n    const quote = response.data;\n\n    // Get token info\n    const inputToken = await this.getTokenInfo(request.chain, request.inputToken);\n    const outputToken = await this.getTokenInfo(request.chain, request.outputToken);\n\n    return {\n      dex: dex.id,\n      inputToken,\n      outputToken,\n      inputAmount: request.amount,\n      outputAmount: quote.toTokenAmount,\n      expectedOutputAmount: quote.toTokenAmount,\n      minimumOutputAmount: quote.toTokenAmount,\n      price: (parseFloat(quote.toTokenAmount) / parseFloat(request.amount)).toString(),\n      priceImpact: (quote.estimatedGas / parseFloat(quote.toTokenAmount) * 100).toString(),\n      slippage: request.slippage.toString(),\n      gasEstimate: {\n        gasLimit: quote.estimatedGas.toString(),\n        gasPrice: quote.gasPrice?.toString() || '0',\n        totalCost: quote.estimatedGas.toString(),\n        totalCostFormatted: '0 ETH'\n      },\n      route: this.parse1inchRoute(quote.protocols),\n      confidence: 85, // 1inch generally reliable\n      executionTime: 2000 // estimated\n    };\n  }\n\n  private async getJupiterQuote(dex: DEXConfig, request: SwapQuoteRequest): Promise<SwapRoute> {\n    const params = new URLSearchParams({\n      inputMint: request.inputToken,\n      outputMint: request.outputToken,\n      amount: request.amount,\n      slippageBps: (request.slippage * 100).toString()\n    });\n\n    const response = await axios.get(`${dex.apiUrl}/quote?${params}`, {\n      timeout: 10000\n    });\n\n    const quote = response.data;\n\n    const inputToken = await this.getTokenInfo(request.chain, request.inputToken);\n    const outputToken = await this.getTokenInfo(request.chain, request.outputToken);\n\n    return {\n      dex: dex.id,\n      inputToken,\n      outputToken,\n      inputAmount: request.amount,\n      outputAmount: quote.outAmount,\n      expectedOutputAmount: quote.outAmount,\n      minimumOutputAmount: quote.otherAmountThreshold,\n      price: (parseFloat(quote.outAmount) / parseFloat(request.amount)).toString(),\n      priceImpact: quote.priceImpactPct || '0',\n      slippage: request.slippage.toString(),\n      gasEstimate: {\n        gasLimit: '200000', // Solana compute units\n        gasPrice: '5000',\n        totalCost: '1000000',\n        totalCostFormatted: '0.001 SOL'\n      },\n      route: this.parseJupiterRoute(quote.routePlan),\n      confidence: 90, // Jupiter is highly optimized\n      executionTime: 1000\n    };\n  }\n\n  private async getUniswapV3Quote(dex: DEXConfig, request: SwapQuoteRequest): Promise<SwapRoute> {\n    // For now, return a simulated quote\n    // In production, this would call Uniswap V3 quoter contract\n    const inputToken = await this.getTokenInfo(request.chain, request.inputToken);\n    const outputToken = await this.getTokenInfo(request.chain, request.outputToken);\n\n    // Simulate price calculation (simplified)\n    const mockPrice = 1.0; // Would get from price oracle\n    const outputAmount = (parseFloat(request.amount) * mockPrice * 0.997).toString(); // 0.3% fee\n\n    return {\n      dex: dex.id,\n      inputToken,\n      outputToken,\n      inputAmount: request.amount,\n      outputAmount,\n      expectedOutputAmount: outputAmount,\n      minimumOutputAmount: (parseFloat(outputAmount) * (1 - request.slippage / 100)).toString(),\n      price: mockPrice.toString(),\n      priceImpact: '0.1',\n      slippage: request.slippage.toString(),\n      gasEstimate: {\n        gasLimit: '150000',\n        gasPrice: '20000000000',\n        totalCost: '3000000000000000',\n        totalCostFormatted: '0.003 ETH'\n      },\n      route: [{\n        dex: dex.id,\n        pool: '0x...',\n        tokenIn: inputToken,\n        tokenOut: outputToken,\n        amountIn: request.amount,\n        amountOut: outputAmount,\n        fee: dex.fee,\n        priceImpact: '0.1'\n      }],\n      confidence: 80,\n      executionTime: 3000\n    };\n  }\n\n  private async getUniswapV2Quote(dex: DEXConfig, request: SwapQuoteRequest): Promise<SwapRoute> {\n    // Similar to V3 but simpler routing\n    const inputToken = await this.getTokenInfo(request.chain, request.inputToken);\n    const outputToken = await this.getTokenInfo(request.chain, request.outputToken);\n\n    const mockPrice = 1.0;\n    const outputAmount = (parseFloat(request.amount) * mockPrice * 0.997).toString();\n\n    return {\n      dex: dex.id,\n      inputToken,\n      outputToken,\n      inputAmount: request.amount,\n      outputAmount,\n      expectedOutputAmount: outputAmount,\n      minimumOutputAmount: (parseFloat(outputAmount) * (1 - request.slippage / 100)).toString(),\n      price: mockPrice.toString(),\n      priceImpact: '0.2',\n      slippage: request.slippage.toString(),\n      gasEstimate: {\n        gasLimit: '120000',\n        gasPrice: '20000000000',\n        totalCost: '2400000000000000',\n        totalCostFormatted: '0.0024 ETH'\n      },\n      route: [{\n        dex: dex.id,\n        pool: '0x...',\n        tokenIn: inputToken,\n        tokenOut: outputToken,\n        amountIn: request.amount,\n        amountOut: outputAmount,\n        fee: dex.fee,\n        priceImpact: '0.2'\n      }],\n      confidence: 75,\n      executionTime: 2500\n    };\n  }\n\n  private async getTokenInfo(chain: string, address: string): Promise<TokenInfo> {\n    // Check cache first\n    const tokenList = this.tokenLists.get(chain) || [];\n    const cachedToken = tokenList.find(token => \n      token.address.toLowerCase() === address.toLowerCase()\n    );\n\n    if (cachedToken) {\n      return cachedToken;\n    }\n\n    // If not in token list, try to fetch from chain\n    try {\n      const balance = await this.chainAbstraction.getBalance(chain, address, address);\n      if (balance.token) {\n        return balance.token;\n      }\n    } catch (error) {\n      // Fallback\n    }\n\n    // Return default token info\n    return {\n      address,\n      symbol: 'UNKNOWN',\n      name: 'Unknown Token',\n      decimals: 18,\n      chainId: this.getChainId(chain)\n    };\n  }\n\n  private parse1inchRoute(protocols: any[]): RouteStep[] {\n    // Parse 1inch protocol route format\n    return protocols.map((protocol: any) => ({\n      dex: protocol.name || '1inch',\n      pool: protocol.part?.toString() || '100',\n      tokenIn: {} as TokenInfo, // Would be populated\n      tokenOut: {} as TokenInfo,\n      amountIn: '0',\n      amountOut: '0',\n      fee: 0,\n      priceImpact: '0'\n    }));\n  }\n\n  private parseJupiterRoute(routePlan: any[]): RouteStep[] {\n    return routePlan.map((step: any) => ({\n      dex: step.swapInfo?.label || 'jupiter',\n      pool: step.swapInfo?.ammKey || '',\n      tokenIn: {} as TokenInfo,\n      tokenOut: {} as TokenInfo,\n      amountIn: step.swapInfo?.inAmount || '0',\n      amountOut: step.swapInfo?.outAmount || '0',\n      fee: step.swapInfo?.feeAmount || 0,\n      priceImpact: '0'\n    }));\n  }\n\n  private selectBestRoute(routes: SwapRoute[], request: SwapQuoteRequest): SwapRoute {\n    // Score routes based on multiple factors\n    const scoredRoutes = routes.map(route => {\n      let score = 0;\n\n      // Output amount (40% weight)\n      const outputScore = parseFloat(route.outputAmount) / Math.max(...routes.map(r => parseFloat(r.outputAmount)));\n      score += outputScore * 0.4;\n\n      // Confidence (25% weight)\n      score += (route.confidence / 100) * 0.25;\n\n      // Gas efficiency (20% weight)\n      const gasScore = 1 - (parseFloat(route.gasEstimate.totalCost) / \n        Math.max(...routes.map(r => parseFloat(r.gasEstimate.totalCost))));\n      score += gasScore * 0.2;\n\n      // Execution time (10% weight)\n      const timeScore = 1 - (route.executionTime / Math.max(...routes.map(r => r.executionTime)));\n      score += timeScore * 0.1;\n\n      // Price impact (5% weight)\n      const impactScore = 1 - (parseFloat(route.priceImpact) / \n        Math.max(...routes.map(r => parseFloat(r.priceImpact))));\n      score += impactScore * 0.05;\n\n      return { route, score };\n    });\n\n    // Return route with highest score\n    return scoredRoutes.reduce((best, current) => \n      current.score > best.score ? current : best\n    ).route;\n  }\n\n  private calculateNetOutput(route: SwapRoute): string {\n    const outputAmount = parseFloat(route.outputAmount);\n    const gasCost = parseFloat(route.gasEstimate.totalCost);\n    \n    // Convert gas cost to output token value (simplified)\n    // In production, would use price oracles\n    const gasCostInOutputToken = gasCost * 0.001; // Rough conversion\n    \n    return Math.max(0, outputAmount - gasCostInOutputToken).toString();\n  }\n\n  private updateStats(chain: string, success: boolean): void {\n    this.stats.totalQuotes++;\n    \n    if (success) {\n      this.stats.successfulQuotes++;\n    }\n\n    // Update chain-specific stats\n    const chainStats = this.stats.chainStats.get(chain) || {\n      quotes: 0,\n      volume: '0',\n      averageSlippage: 0\n    };\n    \n    chainStats.quotes++;\n    this.stats.chainStats.set(chain, chainStats);\n  }\n\n  private updateDEXStats(dexId: string, responseTime: number, success: boolean): void {\n    const stats = this.dexStats.get(dexId);\n    if (!stats) return;\n\n    stats.responseTime = (stats.responseTime * 0.8) + (responseTime * 0.2);\n    \n    if (success) {\n      stats.successRate = Math.min(100, stats.successRate + 0.1);\n    } else {\n      stats.successRate = Math.max(0, stats.successRate - 1);\n    }\n\n    stats.lastUpdated = Date.now();\n  }\n\n  private startStatsCollection(): void {\n    // Log aggregator stats every 10 minutes\n    setInterval(() => {\n      this.logger.info('DEX Aggregator Statistics', {\n        ...this.stats,\n        activeDEXes: Array.from(this.dexConfigs.values()).filter(d => d.isActive).length,\n        chainBreakdown: Object.fromEntries(this.stats.chainStats)\n      });\n    }, 10 * 60 * 1000);\n  }\n\n  // Public API methods\n  getStats(): AggregatorStats {\n    return { ...this.stats };\n  }\n\n  getDEXStats(): Map<string, DEXStats> {\n    return new Map(this.dexStats);\n  }\n\n  getSupportedDEXes(chain?: string): DEXConfig[] {\n    let dexes = Array.from(this.dexConfigs.values());\n    \n    if (chain) {\n      dexes = dexes.filter(dex => dex.chain === chain);\n    }\n    \n    return dexes.filter(dex => dex.isActive);\n  }\n\n  getTokenList(chain: string): TokenInfo[] {\n    return this.tokenLists.get(chain) || [];\n  }\n\n  async enableDEX(dexId: string): Promise<void> {\n    const dex = this.dexConfigs.get(dexId);\n    if (dex) {\n      dex.isActive = true;\n      this.logger.info('DEX enabled', { dexId });\n    }\n  }\n\n  async disableDEX(dexId: string): Promise<void> {\n    const dex = this.dexConfigs.get(dexId);\n    if (dex) {\n      dex.isActive = false;\n      this.logger.info('DEX disabled', { dexId });\n    }\n  }\n\n  async close(): Promise<void> {\n    // Cleanup resources\n    this.priceCache.clear();\n    this.routeCache.clear();\n    this.logger.info('DEX Aggregator closed');\n  }\n}"]}