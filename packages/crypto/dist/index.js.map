{"version":3,"sources":["../index.ts"],"names":["ALGORITHM","encrypt","text","userSalt","length","Error","MASTER_KEY","process","env","encryptionSalt","randomBytes","toString","key","Uint8Array","scryptSync","iv","cipher","createCipheriv","encrypted","update","final","Buffer","from","decrypt","hash","parts","split","salt","ivHex","encryptedText","FALLBACK_SALT","decipher","createDecipheriv","decrypted","SALT_ROUNDS","hashPassword","password","rounds","verifyPassword","compare","error","console","message","createJWT","payload","expiresIn","sub","secret","getJWTSecret","enhancedPayload","jti","generateSecureRandom","SignJWT","setProtectedHeader","alg","setIssuedAt","setExpirationTime","sign","verifyJWT","token","jwtVerify","errors","JWTExpired","JWTInvalid","JWTClaimValidationFailed","createRefreshToken","refreshPayload","type","decodeJWTUnsafe","decodeJwt","TextEncoder","encode","generateAPIKey","prefix","timestamp","Date","now","randomPart","validateAPIKeyFormat","apiKey","expectedPrefix","secureCompare","a","b","result","i","charCodeAt","validateCryptoEnvironment","masterKey","push","jwtSecret","valid","validateEthereumAddress","address","ethAddressRegex","test","validateBitcoinAddress","legacyPattern","p2shPattern","bech32Pattern","createTradingSession","userId","metadata","sessionPayload","sessionId","signMessage","privateKey","algorithm","hmac","createHmac","digest","verifyMessageSignature","signature","expectedSignature","generateSeedPhrase","entropyBits","validEntropyBits","includes","generateMnemonic","validateSeedPhrase","seedPhrase","validateMnemonic","trim","mnemonicToSeed","mnemonic","passphrase","mnemonicToEntropy","entropyToMnemonic","entropy","createRateLimitedToken","identifier","rateLimit","timeWindow","rateLimitPayload","windowStart","Math","floor","deriveKey","derivationPath","keyLength","createHash","derivedKey","securityEvents","securityMetrics","totalEvents","failedLogins","successfulLogins","invalidTokens","rateLimitExceeded","suspiciousActivity","lastUpdated","logSecurityEvent","level","category","context","event","splice","getSecurityEvents","filters","limit","filteredEvents","filter","since","undefined","sort","slice","getSecurityMetrics","detectSuspiciousActivity","ipAddress","recentEvents","ipAddresses","uniqueIPs","Set","size","rateLimitViolations","isSuspicious","monitorFailedAttempts","maxAttempts","failedAttempts","thresholdExceeded","attempts","generateSecurityReport","criticalEvents","errorEvents","warningEvents","recommendations","riskLevel","summary","topEvents","rotateEncryptionKey","currentKey","rotationReason","newKey","keyId","rotationTimestamp","previousKeyHash","substring","validateSecurityPosture","issues","score","envValidation","metrics","failureRate","toFixed","compliance","max"],"mappings":"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","file":"index.js","sourcesContent":["import { createCipheriv, createDecipheriv, scryptSync, randomBytes, createHash, createHmac } from 'crypto';\r\nimport * as bcrypt from 'bcryptjs';\r\nimport * as jose from 'jose';\r\nimport * as bip39 from 'bip39';\r\n\r\nconst ALGORITHM = 'aes-256-cbc';\r\n\r\n// Legacy cached key approach removed for security\r\n// All encryption now uses per-operation salt generation for maximum security\r\n\r\n/**\r\n * Encrypts a plaintext string with per-encryption salt for maximum security.\r\n * @param text The plaintext to encrypt.\r\n * @param userSalt Optional user-specific salt for additional security\r\n * @returns A string containing the salt, IV and the encrypted text, separated by colons.\r\n * @throws Error if MASTER_ENCRYPTION_KEY is not set or text is empty\r\n */\r\nexport function encrypt(text: string, userSalt?: string): string {\r\n    if (!text || text.length === 0) {\r\n        throw new Error('Cannot encrypt empty text');\r\n    }\r\n    \r\n    const MASTER_KEY = process.env['MASTER_ENCRYPTION_KEY'];\r\n    if (!MASTER_KEY) {\r\n        throw new Error('FATAL: MASTER_ENCRYPTION_KEY environment variable is not set.');\r\n    }\r\n    \r\n    if (MASTER_KEY.length < 32) {\r\n        throw new Error('FATAL: MASTER_ENCRYPTION_KEY must be at least 32 characters long.');\r\n    }\r\n    \r\n    // Generate a random salt for this encryption operation\r\n    const encryptionSalt = userSalt || randomBytes(32).toString('hex');\r\n    const key = new Uint8Array(scryptSync(MASTER_KEY, encryptionSalt, 32));\r\n    \r\n    const iv = new Uint8Array(randomBytes(16)); // Initialization vector\r\n    const cipher = createCipheriv(ALGORITHM, key, iv);\r\n    let encrypted = cipher.update(text, 'utf8', 'hex');\r\n    encrypted += cipher.final('hex');\r\n    \r\n    // Return salt:iv:encrypted for maximum security\r\n    return `${encryptionSalt}:${Buffer.from(iv).toString('hex')}:${encrypted}`;\r\n}\r\n\r\n/**\r\n * Decrypts a string that was encrypted with the encrypt function.\r\n * @param hash A string containing the salt, IV and encrypted text, separated by colons.\r\n * @returns The decrypted plaintext.\r\n * @throws Error if hash format is invalid or MASTER_ENCRYPTION_KEY is not set\r\n */\r\nexport function decrypt(hash: string): string {\r\n    if (!hash || hash.length === 0) {\r\n        throw new Error('Cannot decrypt empty hash');\r\n    }\r\n    \r\n    const MASTER_KEY = process.env['MASTER_ENCRYPTION_KEY'];\r\n    if (!MASTER_KEY) {\r\n        throw new Error('FATAL: MASTER_ENCRYPTION_KEY environment variable is not set.');\r\n    }\r\n    \r\n    if (MASTER_KEY.length < 32) {\r\n        throw new Error('FATAL: MASTER_ENCRYPTION_KEY must be at least 32 characters long.');\r\n    }\r\n    \r\n    const parts = hash.split(':');\r\n    \r\n    // Handle both old format (iv:encrypted) and new format (salt:iv:encrypted)\r\n    let salt: string, ivHex: string, encryptedText: string;\r\n    \r\n    if (parts.length === 2) {\r\n        // Old format - use fallback key derivation\r\n        ivHex = parts[0] || '';\r\n        encryptedText = parts[1] || '';\r\n        const FALLBACK_SALT = process.env['ENCRYPTION_SALT'] || 'TradingBot2024SecureSalt';\r\n        salt = FALLBACK_SALT;\r\n    } else if (parts.length === 3) {\r\n        // New format with salt\r\n        salt = parts[0] || '';\r\n        ivHex = parts[1] || '';\r\n        encryptedText = parts[2] || '';\r\n    } else {\r\n        throw new Error('Invalid hash format for decryption. Expected format: salt:iv:encrypted or iv:encrypted');\r\n    }\r\n    \r\n    if (!ivHex || !encryptedText) {\r\n        throw new Error('Invalid hash format for decryption - missing IV or encrypted text.');\r\n    }\r\n    \r\n    // Derive key using the salt from the encrypted data\r\n    const key = new Uint8Array(scryptSync(MASTER_KEY, salt, 32));\r\n    const iv = new Uint8Array(Buffer.from(ivHex, 'hex'));\r\n    const decipher = createDecipheriv(ALGORITHM, key, iv);\r\n    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\r\n    decrypted += decipher.final('utf8');\r\n    return decrypted;\r\n}\r\n\r\n// Password hashing functions\r\nconst SALT_ROUNDS = 12; // Higher value = more secure but slower\r\n\r\n/**\r\n * Hashes a password using bcrypt with configurable salt rounds\r\n * @param password The plain text password to hash\r\n * @param rounds Optional number of salt rounds (default: 12)\r\n * @returns Promise resolving to the hashed password\r\n * @throws Error if password is too short or invalid\r\n */\r\nexport async function hashPassword(password: string, rounds: number = SALT_ROUNDS): Promise<string> {\r\n    if (!password || typeof password !== 'string') {\r\n        throw new Error('Password must be a non-empty string');\r\n    }\r\n    if (password.length < 8) {\r\n        throw new Error('Password must be at least 8 characters long');\r\n    }\r\n    if (rounds < 4 || rounds > 31) {\r\n        throw new Error('Salt rounds must be between 4 and 31');\r\n    }\r\n    return bcrypt.hash(password, rounds);\r\n}\r\n\r\n/**\r\n * Verifies a password against a hash\r\n * @param password The plain text password to verify\r\n * @param hash The hash to verify against\r\n * @returns Promise resolving to true if password matches\r\n */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n    if (!password || !hash || typeof password !== 'string' || typeof hash !== 'string') {\r\n        return false;\r\n    }\r\n    try {\r\n        return await bcrypt.compare(password, hash);\r\n    } catch (error) {\r\n        // Log error for monitoring but don't expose details\r\n        console.error('Password verification failed:', error instanceof Error ? error.message : 'Unknown error');\r\n        return false;\r\n    }\r\n}\r\n\r\n// JWT functions\r\ninterface JWTPayload extends Record<string, any> {\r\n    sub: string; // User ID\r\n    email?: string;\r\n    iat?: number;\r\n    exp?: number;\r\n    jti?: string; // JWT ID for token revocation\r\n}\r\n\r\n/**\r\n * Creates a JWT token with enhanced security features\r\n * @param payload The payload to encode in the token\r\n * @param expiresIn Token expiration time (default: 24h)\r\n * @returns Promise resolving to the JWT token\r\n * @throws Error if JWT_SECRET is not set or payload is invalid\r\n */\r\nexport async function createJWT(\r\n    payload: JWTPayload, \r\n    expiresIn: string | number = '24h'\r\n): Promise<string> {\r\n    if (!payload || typeof payload !== 'object') {\r\n        throw new Error('JWT payload must be a valid object');\r\n    }\r\n    if (!payload.sub || typeof payload.sub !== 'string') {\r\n        throw new Error('JWT payload must include a valid subject (sub)');\r\n    }\r\n    \r\n    const secret = getJWTSecret();\r\n    \r\n    // Add JWT ID for token revocation capabilities\r\n    const enhancedPayload = {\r\n        ...payload,\r\n        jti: payload.jti || generateSecureRandom(16)\r\n    };\r\n    \r\n    return await new jose.SignJWT(enhancedPayload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime(expiresIn)\r\n        .sign(secret);\r\n}\r\n\r\n/**\r\n * Verifies a JWT token with enhanced error handling\r\n * @param token The JWT token to verify\r\n * @returns Promise resolving to the payload if valid\r\n * @throws Error if token is invalid, expired, or malformed\r\n */\r\nexport async function verifyJWT(token: string): Promise<JWTPayload> {\r\n    if (!token || typeof token !== 'string') {\r\n        throw new Error('Token must be a non-empty string');\r\n    }\r\n    \r\n    const secret = getJWTSecret();\r\n    \r\n    try {\r\n        const { payload } = await jose.jwtVerify(token, secret);\r\n        \r\n        // Validate required fields\r\n        if (!payload.sub || typeof payload.sub !== 'string') {\r\n            throw new Error('Invalid token: missing or invalid subject');\r\n        }\r\n        \r\n        return payload as JWTPayload;\r\n    } catch (error) {\r\n        if (error instanceof jose.errors.JWTExpired) {\r\n            throw new Error('Token has expired');\r\n        } else if (error instanceof jose.errors.JWTInvalid) {\r\n            throw new Error('Invalid token format');\r\n        } else if (error instanceof jose.errors.JWTClaimValidationFailed) {\r\n            throw new Error('Token claim validation failed');\r\n        } else {\r\n            throw new Error('Token verification failed');\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a refresh token with longer expiration and additional security\r\n * @param payload The payload to encode in the refresh token\r\n * @param expiresIn Token expiration time (default: 7d)\r\n * @returns Promise resolving to the refresh token\r\n */\r\nexport async function createRefreshToken(\r\n    payload: JWTPayload, \r\n    expiresIn: string = '7d'\r\n): Promise<string> {\r\n    if (!payload || typeof payload !== 'object') {\r\n        throw new Error('Refresh token payload must be a valid object');\r\n    }\r\n    \r\n    const secret = getJWTSecret();\r\n    \r\n    // Add refresh token specific claims\r\n    const refreshPayload = {\r\n        ...payload,\r\n        type: 'refresh',\r\n        jti: generateSecureRandom(16)\r\n    };\r\n    \r\n    return await new jose.SignJWT(refreshPayload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime(expiresIn)\r\n        .sign(secret);\r\n}\r\n\r\n/**\r\n * Extracts JWT payload without verification (for debugging only)\r\n * @param token The JWT token to decode\r\n * @returns The decoded payload\r\n * @warning This does not verify the token signature - use only for debugging\r\n */\r\nexport function decodeJWTUnsafe(token: string): JWTPayload | null {\r\n    if (!token || typeof token !== 'string') {\r\n        return null;\r\n    }\r\n    \r\n    try {\r\n        return jose.decodeJwt(token) as JWTPayload;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\n// Helper function to get JWT secret with enhanced validation\r\nfunction getJWTSecret(): Uint8Array {\r\n    const secret = process.env['JWT_SECRET'];\r\n    if (!secret) {\r\n        throw new Error('JWT_SECRET environment variable is not set');\r\n    }\r\n    if (secret.length < 32) {\r\n        throw new Error('JWT_SECRET must be at least 32 characters long for security');\r\n    }\r\n    return new TextEncoder().encode(secret);\r\n}\r\n\r\n// Enhanced secure random string generation\r\nexport function generateSecureRandom(length: number = 32): string {\r\n    if (length < 1 || length > 256) {\r\n        throw new Error('Random string length must be between 1 and 256');\r\n    }\r\n    return randomBytes(length).toString('hex');\r\n}\r\n\r\n// Generate a secure API key with enhanced format\r\nexport function generateAPIKey(prefix: string = 'tb'): string {\r\n    if (!prefix || typeof prefix !== 'string' || prefix.length === 0) {\r\n        throw new Error('API key prefix must be a non-empty string');\r\n    }\r\n    \r\n    const timestamp = Date.now().toString(36);\r\n    const randomPart = generateSecureRandom(32);\r\n    return `${prefix}_${timestamp}_${randomPart}`;\r\n}\r\n\r\n/**\r\n * Validates if a string is a properly formatted API key\r\n * @param apiKey The API key to validate\r\n * @param expectedPrefix Expected prefix (default: 'tb')\r\n * @returns True if the API key format is valid\r\n */\r\nexport function validateAPIKeyFormat(apiKey: string, expectedPrefix: string = 'tb'): boolean {\r\n    if (!apiKey || typeof apiKey !== 'string') {\r\n        return false;\r\n    }\r\n    \r\n    const parts = apiKey.split('_');\r\n    if (parts.length !== 3) {\r\n        return false;\r\n    }\r\n    \r\n    const prefix = parts[0] || '';\r\n    const timestamp = parts[1] || '';\r\n    const randomPart = parts[2] || '';\r\n    return prefix === expectedPrefix && \r\n           timestamp.length > 0 && \r\n           randomPart.length === 64; // 32 bytes = 64 hex chars\r\n}\r\n\r\n/**\r\n * Securely compares two strings to prevent timing attacks\r\n * @param a First string\r\n * @param b Second string\r\n * @returns True if strings are equal\r\n */\r\nexport function secureCompare(a: string, b: string): boolean {\r\n    if (typeof a !== 'string' || typeof b !== 'string') {\r\n        return false;\r\n    }\r\n    \r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    \r\n    let result = 0;\r\n    for (let i = 0; i < a.length; i++) {\r\n        result |= a.charCodeAt(i) ^ b.charCodeAt(i);\r\n    }\r\n    \r\n    return result === 0;\r\n}\r\n\r\n// Environment validation for production readiness\r\nexport function validateCryptoEnvironment(): { valid: boolean; errors: string[] } {\r\n    const errors: string[] = [];\r\n    \r\n    const masterKey = process.env['MASTER_ENCRYPTION_KEY'];\r\n    if (!masterKey) {\r\n        errors.push('MASTER_ENCRYPTION_KEY environment variable is not set');\r\n    } else if (masterKey.length < 32) {\r\n        errors.push('MASTER_ENCRYPTION_KEY must be at least 32 characters long');\r\n    }\r\n    \r\n    const jwtSecret = process.env['JWT_SECRET'];\r\n    if (!jwtSecret) {\r\n        errors.push('JWT_SECRET environment variable is not set');\r\n    } else if (jwtSecret.length < 32) {\r\n        errors.push('JWT_SECRET must be at least 32 characters long');\r\n    }\r\n    \r\n    return {\r\n        valid: errors.length === 0,\r\n        errors\r\n    };\r\n}\r\n\r\n// ==========================================\r\n// TRADING-SPECIFIC CRYPTOGRAPHIC UTILITIES\r\n// ==========================================\r\n\r\n/**\r\n * Validates Ethereum wallet address format\r\n * @param address The wallet address to validate\r\n * @returns True if address format is valid\r\n */\r\nexport function validateEthereumAddress(address: string): boolean {\r\n    if (!address || typeof address !== 'string') {\r\n        return false;\r\n    }\r\n    \r\n    // Basic Ethereum address validation (0x + 40 hex chars)\r\n    const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;\r\n    return ethAddressRegex.test(address);\r\n}\r\n\r\n/**\r\n * Validates Bitcoin wallet address format (Legacy, P2SH, Bech32)\r\n * @param address The Bitcoin address to validate\r\n * @returns True if address format is valid\r\n */\r\nexport function validateBitcoinAddress(address: string): boolean {\r\n    if (!address || typeof address !== 'string') {\r\n        return false;\r\n    }\r\n    \r\n    // Basic Bitcoin address validation patterns\r\n    const legacyPattern = /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/;\r\n    const p2shPattern = /^3[a-km-zA-HJ-NP-Z1-9]{25,34}$/;\r\n    const bech32Pattern = /^bc1[a-z0-9]{39,59}$/;\r\n    \r\n    return legacyPattern.test(address) || p2shPattern.test(address) || bech32Pattern.test(address);\r\n}\r\n\r\n/**\r\n * Generates a secure trading session token with metadata\r\n * @param userId User identifier\r\n * @param metadata Additional session metadata\r\n * @param expiresIn Session expiration (default: 4h)\r\n * @returns Promise resolving to session token\r\n */\r\nexport async function createTradingSession(\r\n    userId: string, \r\n    metadata: Record<string, any> = {},\r\n    expiresIn: string = '4h'\r\n): Promise<string> {\r\n    if (!userId || typeof userId !== 'string') {\r\n        throw new Error('User ID must be a non-empty string');\r\n    }\r\n    \r\n    const sessionPayload: JWTPayload = {\r\n        sub: userId,\r\n        type: 'trading_session',\r\n        metadata,\r\n        sessionId: generateSecureRandom(16),\r\n        jti: generateSecureRandom(16)\r\n    };\r\n    \r\n    return createJWT(sessionPayload, expiresIn);\r\n}\r\n\r\n/**\r\n * Creates a secure message signature for API authentication\r\n * @param message The message to sign\r\n * @param privateKey The private key for signing\r\n * @param algorithm Hash algorithm (default: sha256)\r\n * @returns The message signature\r\n */\r\nexport function signMessage(message: string, privateKey: string, algorithm: string = 'sha256'): string {\r\n    if (!message || !privateKey) {\r\n        throw new Error('Message and private key are required');\r\n    }\r\n    \r\n    const hmac = createHmac(algorithm, privateKey);\r\n    hmac.update(message);\r\n    return hmac.digest('hex');\r\n}\r\n\r\n/**\r\n * Verifies a message signature\r\n * @param message The original message\r\n * @param signature The signature to verify\r\n * @param privateKey The private key used for signing\r\n * @param algorithm Hash algorithm (default: sha256)\r\n * @returns True if signature is valid\r\n */\r\nexport function verifyMessageSignature(\r\n    message: string, \r\n    signature: string, \r\n    privateKey: string, \r\n    algorithm: string = 'sha256'\r\n): boolean {\r\n    if (!message || !signature || !privateKey) {\r\n        return false;\r\n    }\r\n    \r\n    try {\r\n        const expectedSignature = signMessage(message, privateKey, algorithm);\r\n        return secureCompare(signature, expectedSignature);\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Generates a secure BIP39 seed phrase for HD wallet creation - Production Ready\r\n * @param entropyBits Entropy bits (128, 160, 192, 224, 256) mapping to (12, 15, 18, 21, 24) words\r\n * @returns Secure BIP39 compliant seed phrase\r\n */\r\nexport function generateSeedPhrase(entropyBits: number = 128): string {\r\n    const validEntropyBits = [128, 160, 192, 224, 256];\r\n    if (!validEntropyBits.includes(entropyBits)) {\r\n        throw new Error('Entropy bits must be 128, 160, 192, 224, or 256 (corresponding to 12, 15, 18, 21, or 24 words)');\r\n    }\r\n    \r\n    try {\r\n        return bip39.generateMnemonic(entropyBits);\r\n    } catch (error) {\r\n        throw new Error(`Failed to generate BIP39 mnemonic: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Validates BIP39 seed phrase format, checksum, and wordlist compliance - Production Ready\r\n * @param seedPhrase The seed phrase to validate\r\n * @returns True if seed phrase is valid BIP39 compliant\r\n */\r\nexport function validateSeedPhrase(seedPhrase: string): boolean {\r\n    if (!seedPhrase || typeof seedPhrase !== 'string') {\r\n        return false;\r\n    }\r\n    \r\n    try {\r\n        return bip39.validateMnemonic(seedPhrase.trim());\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Converts BIP39 mnemonic to cryptographic seed for key derivation - Production Ready\r\n * @param mnemonic Valid BIP39 mnemonic phrase\r\n * @param passphrase Optional passphrase for additional security\r\n * @returns Promise resolving to 512-bit seed as Buffer\r\n */\r\nexport async function mnemonicToSeed(mnemonic: string, passphrase?: string): Promise<Buffer> {\r\n    if (!validateSeedPhrase(mnemonic)) {\r\n        throw new Error('Invalid BIP39 mnemonic phrase');\r\n    }\r\n    \r\n    try {\r\n        return await bip39.mnemonicToSeed(mnemonic, passphrase);\r\n    } catch (error) {\r\n        throw new Error(`Failed to generate seed from mnemonic: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts BIP39 mnemonic to entropy bytes - Production Ready\r\n * @param mnemonic Valid BIP39 mnemonic phrase\r\n * @returns Entropy as hex string\r\n */\r\nexport function mnemonicToEntropy(mnemonic: string): string {\r\n    if (!validateSeedPhrase(mnemonic)) {\r\n        throw new Error('Invalid BIP39 mnemonic phrase');\r\n    }\r\n    \r\n    try {\r\n        return bip39.mnemonicToEntropy(mnemonic);\r\n    } catch (error) {\r\n        throw new Error(`Failed to extract entropy from mnemonic: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts entropy to BIP39 mnemonic - Production Ready\r\n * @param entropy Entropy as hex string or Buffer\r\n * @returns BIP39 mnemonic phrase\r\n */\r\nexport function entropyToMnemonic(entropy: string | Buffer): string {\r\n    try {\r\n        return bip39.entropyToMnemonic(entropy);\r\n    } catch (error) {\r\n        throw new Error(`Failed to generate mnemonic from entropy: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a rate-limited token for API access control\r\n * @param identifier Client identifier\r\n * @param rateLimit Requests per time window\r\n * @param timeWindow Time window in seconds (default: 3600)\r\n * @returns Rate-limited token\r\n */\r\nexport async function createRateLimitedToken(\r\n    identifier: string, \r\n    rateLimit: number, \r\n    timeWindow: number = 3600\r\n): Promise<string> {\r\n    if (!identifier || rateLimit <= 0 || timeWindow <= 0) {\r\n        throw new Error('Invalid rate limit parameters');\r\n    }\r\n    \r\n    const rateLimitPayload: JWTPayload = {\r\n        sub: identifier,\r\n        type: 'rate_limited',\r\n        rateLimit,\r\n        timeWindow,\r\n        windowStart: Math.floor(Date.now() / 1000),\r\n        jti: generateSecureRandom(16)\r\n    };\r\n    \r\n    return createJWT(rateLimitPayload, '24h');\r\n}\r\n\r\n/**\r\n * Derives a deterministic key from master key and derivation path\r\n * @param masterKey The master key\r\n * @param derivationPath The derivation path (e.g., \"m/44'/60'/0'/0/0\")\r\n * @param keyLength Output key length in bytes (default: 32)\r\n * @returns Derived key as hex string\r\n */\r\nexport function deriveKey(masterKey: string, derivationPath: string, keyLength: number = 32): string {\r\n    if (!masterKey || !derivationPath) {\r\n        throw new Error('Master key and derivation path are required');\r\n    }\r\n    \r\n    if (keyLength < 16 || keyLength > 64) {\r\n        throw new Error('Key length must be between 16 and 64 bytes');\r\n    }\r\n    \r\n    // Simple key derivation (in production, use proper PBKDF2 or similar)\r\n    const salt = createHash('sha256').update(derivationPath).digest();\r\n    const derivedKey = scryptSync(masterKey, salt, keyLength);\r\n    \r\n    return derivedKey.toString('hex');\r\n}\r\n\r\n// ==========================================\r\n// SECURITY MONITORING & ALERTING SYSTEM\r\n// ==========================================\r\n\r\ninterface SecurityEvent {\r\n    timestamp: number;\r\n    level: 'info' | 'warning' | 'error' | 'critical';\r\n    category: string;\r\n    message: string;\r\n    userId?: string;\r\n    ipAddress?: string;\r\n    userAgent?: string;\r\n    metadata?: Record<string, any>;\r\n}\r\n\r\ninterface SecurityMetrics {\r\n    totalEvents: number;\r\n    failedLogins: number;\r\n    successfulLogins: number;\r\n    invalidTokens: number;\r\n    rateLimitExceeded: number;\r\n    suspiciousActivity: number;\r\n    lastUpdated: number;\r\n}\r\n\r\n// In-memory storage for demo (use proper database in production)\r\nconst securityEvents: SecurityEvent[] = [];\r\nconst securityMetrics: SecurityMetrics = {\r\n    totalEvents: 0,\r\n    failedLogins: 0,\r\n    successfulLogins: 0,\r\n    invalidTokens: 0,\r\n    rateLimitExceeded: 0,\r\n    suspiciousActivity: 0,\r\n    lastUpdated: Date.now()\r\n};\r\n\r\n/**\r\n * Logs a security event for monitoring and alerting\r\n * @param level Event severity level\r\n * @param category Event category\r\n * @param message Event message\r\n * @param context Additional context information\r\n */\r\nexport function logSecurityEvent(\r\n    level: 'info' | 'warning' | 'error' | 'critical',\r\n    category: string,\r\n    message: string,\r\n    context: {\r\n        userId?: string;\r\n        ipAddress?: string;\r\n        userAgent?: string;\r\n        metadata?: Record<string, any>;\r\n    } = {}\r\n): void {\r\n    const event: SecurityEvent = {\r\n        timestamp: Date.now(),\r\n        level,\r\n        category,\r\n        message,\r\n        ...context\r\n    };\r\n    \r\n    securityEvents.push(event);\r\n    securityMetrics.totalEvents++;\r\n    securityMetrics.lastUpdated = Date.now();\r\n    \r\n    // Update specific metrics\r\n    switch (category) {\r\n        case 'authentication':\r\n            if (level === 'error') {\r\n                securityMetrics.failedLogins++;\r\n            } else if (level === 'info') {\r\n                securityMetrics.successfulLogins++;\r\n            }\r\n            break;\r\n        case 'token_validation':\r\n            if (level === 'error') {\r\n                securityMetrics.invalidTokens++;\r\n            }\r\n            break;\r\n        case 'rate_limiting':\r\n            if (level === 'warning') {\r\n                securityMetrics.rateLimitExceeded++;\r\n            }\r\n            break;\r\n        case 'suspicious_activity':\r\n            securityMetrics.suspiciousActivity++;\r\n            break;\r\n    }\r\n    \r\n    // Auto-alert on critical events\r\n    if (level === 'critical') {\r\n        console.error(`🚨 CRITICAL SECURITY EVENT: ${category} - ${message}`, context);\r\n    }\r\n    \r\n    // Cleanup old events (keep last 10000)\r\n    if (securityEvents.length > 10000) {\r\n        securityEvents.splice(0, securityEvents.length - 10000);\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves security events with optional filtering\r\n * @param filters Optional filters for events\r\n * @param limit Maximum number of events to return\r\n * @returns Array of filtered security events\r\n */\r\nexport function getSecurityEvents(\r\n    filters: {\r\n        level?: 'info' | 'warning' | 'error' | 'critical';\r\n        category?: string;\r\n        userId?: string;\r\n        since?: number;\r\n    } = {},\r\n    limit: number = 100\r\n): SecurityEvent[] {\r\n    let filteredEvents = [...securityEvents];\r\n    \r\n    if (filters.level) {\r\n        filteredEvents = filteredEvents.filter(event => event.level === filters.level);\r\n    }\r\n    \r\n    if (filters.category) {\r\n        filteredEvents = filteredEvents.filter(event => event.category === filters.category);\r\n    }\r\n    \r\n    if (filters.userId) {\r\n        filteredEvents = filteredEvents.filter(event => event.userId === filters.userId);\r\n    }\r\n    \r\n    if (filters.since !== undefined) {\r\n        filteredEvents = filteredEvents.filter(event => event.timestamp >= filters.since!);\r\n    }\r\n    \r\n    return filteredEvents\r\n        .sort((a, b) => b.timestamp - a.timestamp)\r\n        .slice(0, limit);\r\n}\r\n\r\n/**\r\n * Gets current security metrics and statistics\r\n * @returns Current security metrics\r\n */\r\nexport function getSecurityMetrics(): SecurityMetrics {\r\n    return { ...securityMetrics };\r\n}\r\n\r\n/**\r\n * Detects suspicious authentication patterns\r\n * @param userId User identifier\r\n * @param ipAddress IP address\r\n * @param timeWindow Time window in milliseconds (default: 1 hour)\r\n * @returns True if suspicious activity detected\r\n */\r\nexport function detectSuspiciousActivity(\r\n    userId: string, \r\n    ipAddress: string, \r\n    timeWindow: number = 3600000\r\n): boolean {\r\n    const since = Date.now() - timeWindow;\r\n    const recentEvents = getSecurityEvents({ userId, since }, 1000);\r\n    \r\n    // Check for multiple failed logins\r\n    const failedLogins = recentEvents.filter(\r\n        event => event.category === 'authentication' && event.level === 'error'\r\n    ).length;\r\n    \r\n    // Check for multiple IP addresses\r\n    const ipAddresses: string[] = [];\r\n    for (const event of recentEvents) {\r\n        if (event.ipAddress) {\r\n            ipAddresses.push(event.ipAddress);\r\n        }\r\n    }\r\n    const uniqueIPs = new Set(ipAddresses).size;\r\n    \r\n    // Check for rate limit violations\r\n    const rateLimitViolations = recentEvents.filter(\r\n        event => event.category === 'rate_limiting'\r\n    ).length;\r\n    \r\n    const isSuspicious = failedLogins > 5 || uniqueIPs > 3 || rateLimitViolations > 10;\r\n    \r\n    if (isSuspicious) {\r\n        logSecurityEvent('critical', 'suspicious_activity', \r\n            `Suspicious activity detected for user ${userId}`, {\r\n                userId,\r\n                ipAddress,\r\n                metadata: { failedLogins, uniqueIPs, rateLimitViolations }\r\n            });\r\n    }\r\n    \r\n    return isSuspicious;\r\n}\r\n\r\n/**\r\n * Monitors failed authentication attempts for brute force detection\r\n * @param identifier User ID or IP address\r\n * @param maxAttempts Maximum allowed attempts\r\n * @param timeWindow Time window in milliseconds\r\n * @returns True if threshold exceeded\r\n */\r\nexport function monitorFailedAttempts(\r\n    identifier: string, \r\n    maxAttempts: number = 5, \r\n    timeWindow: number = 900000\r\n): boolean {\r\n    const since = Date.now() - timeWindow;\r\n    const failedAttempts = getSecurityEvents({ since }, 1000)\r\n        .filter(event => \r\n            event.category === 'authentication' && \r\n            event.level === 'error' &&\r\n            (event.userId === identifier || (event.ipAddress && event.ipAddress === identifier))\r\n        ).length;\r\n    \r\n    const thresholdExceeded = failedAttempts >= maxAttempts;\r\n    \r\n    if (thresholdExceeded) {\r\n        logSecurityEvent('warning', 'brute_force', \r\n            `Brute force attempt detected for ${identifier}`, {\r\n                metadata: { attempts: failedAttempts, maxAttempts, timeWindow }\r\n            });\r\n    }\r\n    \r\n    return thresholdExceeded;\r\n}\r\n\r\n/**\r\n * Generates a comprehensive security report\r\n * @param timeWindow Time window for report in milliseconds (default: 24 hours)\r\n * @returns Security report with statistics and recommendations\r\n */\r\nexport function generateSecurityReport(timeWindow: number = 86400000): {\r\n    summary: SecurityMetrics;\r\n    topEvents: SecurityEvent[];\r\n    recommendations: string[];\r\n    riskLevel: 'low' | 'medium' | 'high' | 'critical';\r\n} {\r\n    const since = Date.now() - timeWindow;\r\n    const recentEvents = getSecurityEvents({ since }, 1000);\r\n    \r\n    const criticalEvents = recentEvents.filter(event => event.level === 'critical').length;\r\n    const errorEvents = recentEvents.filter(event => event.level === 'error').length;\r\n    const warningEvents = recentEvents.filter(event => event.level === 'warning').length;\r\n    \r\n    const recommendations: string[] = [];\r\n    let riskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';\r\n    \r\n    if (criticalEvents > 0) {\r\n        riskLevel = 'critical';\r\n        recommendations.push('Immediate action required: Critical security events detected');\r\n    } else if (errorEvents > 10) {\r\n        riskLevel = 'high';\r\n        recommendations.push('High error rate detected - investigate authentication issues');\r\n    } else if (warningEvents > 20) {\r\n        riskLevel = 'medium';\r\n        recommendations.push('Elevated warning level - monitor rate limiting and access patterns');\r\n    }\r\n    \r\n    if (securityMetrics.failedLogins > securityMetrics.successfulLogins * 0.1) {\r\n        recommendations.push('High failed login ratio - consider implementing additional security measures');\r\n    }\r\n    \r\n    if (securityMetrics.rateLimitExceeded > 50) {\r\n        recommendations.push('Frequent rate limit violations - review API usage patterns');\r\n    }\r\n    \r\n    return {\r\n        summary: getSecurityMetrics(),\r\n        topEvents: recentEvents.slice(0, 10),\r\n        recommendations,\r\n        riskLevel\r\n    };\r\n}\r\n\r\n/**\r\n * Advanced key rotation system for enhanced security\r\n * @param currentKey Current encryption key\r\n * @param rotationReason Reason for key rotation\r\n * @returns New encryption key and rotation metadata\r\n */\r\nexport function rotateEncryptionKey(\r\n    currentKey: string,\r\n    rotationReason: string = 'scheduled_rotation'\r\n): {\r\n    newKey: string;\r\n    keyId: string;\r\n    rotationTimestamp: number;\r\n    previousKeyHash: string;\r\n} {\r\n    if (!currentKey || currentKey.length < 32) {\r\n        throw new Error('Current key must be at least 32 characters');\r\n    }\r\n    \r\n    // Generate new key\r\n    const newKey = generateSecureRandom(64);\r\n    const keyId = generateSecureRandom(16);\r\n    const rotationTimestamp = Date.now();\r\n    \r\n    // Create hash of previous key for audit trail\r\n    const previousKeyHash = createHash('sha256').update(currentKey).digest('hex');\r\n    \r\n    // Log key rotation event\r\n    logSecurityEvent('info', 'key_rotation', \r\n        `Encryption key rotated: ${rotationReason}`, {\r\n            metadata: { \r\n                keyId, \r\n                rotationTimestamp, \r\n                previousKeyHash: previousKeyHash.substring(0, 16) + '...' \r\n            }\r\n        });\r\n    \r\n    return {\r\n        newKey,\r\n        keyId,\r\n        rotationTimestamp,\r\n        previousKeyHash\r\n    };\r\n}\r\n\r\n/**\r\n * Validates the overall security posture of the crypto system\r\n * @returns Comprehensive security validation results\r\n */\r\nexport function validateSecurityPosture(): {\r\n    score: number;\r\n    issues: string[];\r\n    recommendations: string[];\r\n    compliance: boolean;\r\n} {\r\n    const issues: string[] = [];\r\n    const recommendations: string[] = [];\r\n    let score = 100;\r\n    \r\n    // Check environment configuration\r\n    const envValidation = validateCryptoEnvironment();\r\n    if (!envValidation.valid) {\r\n        issues.push(...envValidation.errors);\r\n        score -= 20;\r\n    }\r\n    \r\n    // Check recent security events\r\n    const recentEvents = getSecurityEvents({ since: Date.now() - 86400000 }, 100);\r\n    const criticalEvents = recentEvents.filter(event => event.level === 'critical').length;\r\n    \r\n    if (criticalEvents > 0) {\r\n        issues.push(`${criticalEvents} critical security events in the last 24 hours`);\r\n        score -= 30;\r\n    }\r\n    \r\n    // Check metrics\r\n    const metrics = getSecurityMetrics();\r\n    const failureRate = metrics.totalEvents > 0 ? \r\n        (metrics.failedLogins / metrics.totalEvents) * 100 : 0;\r\n    \r\n    if (failureRate > 10) {\r\n        issues.push(`High authentication failure rate: ${failureRate.toFixed(1)}%`);\r\n        score -= 15;\r\n        recommendations.push('Implement additional authentication security measures');\r\n    }\r\n    \r\n    if (metrics.suspiciousActivity > 5) {\r\n        issues.push(`Multiple suspicious activity alerts: ${metrics.suspiciousActivity}`);\r\n        score -= 10;\r\n        recommendations.push('Review and investigate suspicious activity patterns');\r\n    }\r\n    \r\n    // General recommendations based on score\r\n    if (score < 90) {\r\n        recommendations.push('Regular security audits recommended');\r\n    }\r\n    \r\n    if (score < 70) {\r\n        recommendations.push('Immediate security review required');\r\n    }\r\n    \r\n    const compliance = score >= 80 && criticalEvents === 0;\r\n    \r\n    return {\r\n        score: Math.max(0, score),\r\n        issues,\r\n        recommendations,\r\n        compliance\r\n    };\r\n} "]}