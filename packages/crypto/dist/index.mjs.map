{"version":3,"sources":["../src/types.ts","../src/encryption.ts","../src/auth.ts"],"sourcesContent":["import { z } from 'zod';\n\nexport const PrivateKeySchema = z.string().min(1).max(1000);\nexport type PrivateKey = z.infer<typeof PrivateKeySchema>;\n\nexport const MasterKeySchema = z.string().min(32).max(32);\nexport type MasterKey = z.infer<typeof MasterKeySchema>;\n\nexport const EncryptedDataSchema = z.object({\n  iv: z.string(),\n  content: z.string()\n});\nexport type EncryptedData = z.infer<typeof EncryptedDataSchema>;\n\nexport const PasswordHashSchema = z.string();\nexport type PasswordHash = z.infer<typeof PasswordHashSchema>;\n\nexport const JWTPayloadSchema = z.object({\n  userId: z.string(),\n  walletAddress: z.string().optional(),\n  exp: z.number()\n});\nexport type JWTPayload = z.infer<typeof JWTPayloadSchema>;","import { randomBytes, createCipheriv, createDecipheriv } from 'crypto';\nimport { EncryptedData, PrivateKey, MasterKey, PrivateKeySchema, MasterKeySchema } from './types';\n\nconst ALGORITHM = 'aes-256-cbc';\nconst IV_LENGTH = 16;\nconst ENCODING = 'hex';\n\nexport class EncryptionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'EncryptionError';\n  }\n}\n\nexport function encryptPrivateKey(privateKey: PrivateKey, masterKey: MasterKey): EncryptedData {\n  try {\n    // Validate inputs\n    PrivateKeySchema.parse(privateKey);\n    MasterKeySchema.parse(masterKey);\n\n    // Generate random IV\n    const iv = randomBytes(IV_LENGTH);\n    \n    // Create cipher\n    const cipher = createCipheriv(ALGORITHM, Buffer.from(masterKey), iv);\n    \n    // Encrypt\n    let encrypted = cipher.update(privateKey, 'utf8', ENCODING);\n    encrypted += cipher.final(ENCODING);\n    \n    return {\n      iv: iv.toString(ENCODING),\n      content: encrypted\n    };\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new EncryptionError(`Failed to encrypt private key: ${error.message}`);\n    }\n    throw new EncryptionError('Failed to encrypt private key');\n  }\n}\n\nexport function decryptPrivateKey(encrypted: EncryptedData, masterKey: MasterKey): PrivateKey {\n  try {\n    // Validate master key\n    MasterKeySchema.parse(masterKey);\n    \n    // Create decipher\n    const decipher = createDecipheriv(\n      ALGORITHM,\n      Buffer.from(masterKey),\n      Buffer.from(encrypted.iv, ENCODING)\n    );\n    \n    // Decrypt\n    let decrypted = decipher.update(encrypted.content, ENCODING, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    // Validate decrypted value\n    return PrivateKeySchema.parse(decrypted);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new EncryptionError(`Failed to decrypt private key: ${error.message}`);\n    }\n    throw new EncryptionError('Failed to decrypt private key');\n  }\n}","import { hash, compare } from 'bcryptjs';\nimport { sign, verify } from 'jsonwebtoken';\nimport { PasswordHash, JWTPayload, JWTPayloadSchema } from './types';\n\nconst SALT_ROUNDS = 12;\n\nexport class AuthError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AuthError';\n  }\n}\n\nexport async function hashPassword(password: string): Promise<PasswordHash> {\n  try {\n    return await hash(password, SALT_ROUNDS);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new AuthError(`Failed to hash password: ${error.message}`);\n    }\n    throw new AuthError('Failed to hash password');\n  }\n}\n\nexport async function verifyPassword(password: string, hashedPassword: PasswordHash): Promise<boolean> {\n  try {\n    return await compare(password, hashedPassword);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new AuthError(`Failed to verify password: ${error.message}`);\n    }\n    throw new AuthError('Failed to verify password');\n  }\n}\n\nexport function generateToken(payload: JWTPayload, secret: string, expiresIn: string = '24h'): string {\n  try {\n    // Validate payload\n    JWTPayloadSchema.parse(payload);\n    return sign(payload, secret, { expiresIn });\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new AuthError(`Failed to generate token: ${error.message}`);\n    }\n    throw new AuthError('Failed to generate token');\n  }\n}\n\nexport function verifyToken(token: string, secret: string): JWTPayload {\n  try {\n    const decoded = verify(token, secret);\n    return JWTPayloadSchema.parse(decoded);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new AuthError(`Failed to verify token: ${error.message}`);\n    }\n    throw new AuthError('Failed to verify token');\n  }\n}"],"mappings":";AAAA,SAAS,SAAS;AAEX,IAAM,mBAAmB,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,GAAI;AAGnD,IAAM,kBAAkB,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE;AAGjD,IAAM,sBAAsB,EAAE,OAAO;AAAA,EAC1C,IAAI,EAAE,OAAO;AAAA,EACb,SAAS,EAAE,OAAO;AACpB,CAAC;AAGM,IAAM,qBAAqB,EAAE,OAAO;AAGpC,IAAM,mBAAmB,EAAE,OAAO;AAAA,EACvC,QAAQ,EAAE,OAAO;AAAA,EACjB,eAAe,EAAE,OAAO,EAAE,SAAS;AAAA,EACnC,KAAK,EAAE,OAAO;AAChB,CAAC;;;ACrBD,SAAS,aAAa,gBAAgB,wBAAwB;AAG9D,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,WAAW;AAEV,IAAM,kBAAN,cAA8B,MAAM;AAAA,EACzC,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAEO,SAAS,kBAAkB,YAAwB,WAAqC;AAC7F,MAAI;AAEF,qBAAiB,MAAM,UAAU;AACjC,oBAAgB,MAAM,SAAS;AAG/B,UAAM,KAAK,YAAY,SAAS;AAGhC,UAAM,SAAS,eAAe,WAAW,OAAO,KAAK,SAAS,GAAG,EAAE;AAGnE,QAAI,YAAY,OAAO,OAAO,YAAY,QAAQ,QAAQ;AAC1D,iBAAa,OAAO,MAAM,QAAQ;AAElC,WAAO;AAAA,MACL,IAAI,GAAG,SAAS,QAAQ;AAAA,MACxB,SAAS;AAAA,IACX;AAAA,EACF,SAAS,OAAO;AACd,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI,gBAAgB,kCAAkC,MAAM,OAAO,EAAE;AAAA,IAC7E;AACA,UAAM,IAAI,gBAAgB,+BAA+B;AAAA,EAC3D;AACF;AAEO,SAAS,kBAAkB,WAA0B,WAAkC;AAC5F,MAAI;AAEF,oBAAgB,MAAM,SAAS;AAG/B,UAAM,WAAW;AAAA,MACf;AAAA,MACA,OAAO,KAAK,SAAS;AAAA,MACrB,OAAO,KAAK,UAAU,IAAI,QAAQ;AAAA,IACpC;AAGA,QAAI,YAAY,SAAS,OAAO,UAAU,SAAS,UAAU,MAAM;AACnE,iBAAa,SAAS,MAAM,MAAM;AAGlC,WAAO,iBAAiB,MAAM,SAAS;AAAA,EACzC,SAAS,OAAO;AACd,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI,gBAAgB,kCAAkC,MAAM,OAAO,EAAE;AAAA,IAC7E;AACA,UAAM,IAAI,gBAAgB,+BAA+B;AAAA,EAC3D;AACF;;;AClEA,SAAS,MAAM,eAAe;AAC9B,SAAS,MAAM,cAAc;AAG7B,IAAM,cAAc;AAEb,IAAM,YAAN,cAAwB,MAAM;AAAA,EACnC,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAEA,eAAsB,aAAa,UAAyC;AAC1E,MAAI;AACF,WAAO,MAAM,KAAK,UAAU,WAAW;AAAA,EACzC,SAAS,OAAO;AACd,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI,UAAU,4BAA4B,MAAM,OAAO,EAAE;AAAA,IACjE;AACA,UAAM,IAAI,UAAU,yBAAyB;AAAA,EAC/C;AACF;AAEA,eAAsB,eAAe,UAAkB,gBAAgD;AACrG,MAAI;AACF,WAAO,MAAM,QAAQ,UAAU,cAAc;AAAA,EAC/C,SAAS,OAAO;AACd,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI,UAAU,8BAA8B,MAAM,OAAO,EAAE;AAAA,IACnE;AACA,UAAM,IAAI,UAAU,2BAA2B;AAAA,EACjD;AACF;AAEO,SAAS,cAAc,SAAqB,QAAgB,YAAoB,OAAe;AACpG,MAAI;AAEF,qBAAiB,MAAM,OAAO;AAC9B,WAAO,KAAK,SAAS,QAAQ,EAAE,UAAU,CAAC;AAAA,EAC5C,SAAS,OAAO;AACd,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI,UAAU,6BAA6B,MAAM,OAAO,EAAE;AAAA,IAClE;AACA,UAAM,IAAI,UAAU,0BAA0B;AAAA,EAChD;AACF;AAEO,SAAS,YAAY,OAAe,QAA4B;AACrE,MAAI;AACF,UAAM,UAAU,OAAO,OAAO,MAAM;AACpC,WAAO,iBAAiB,MAAM,OAAO;AAAA,EACvC,SAAS,OAAO;AACd,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI,UAAU,2BAA2B,MAAM,OAAO,EAAE;AAAA,IAChE;AACA,UAAM,IAAI,UAAU,wBAAwB;AAAA,EAC9C;AACF;","names":[]}